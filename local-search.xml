<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/omcat.github.io/2026/02/21/WSL%E5%92%8C%E8%BF%9C%E7%A8%8BUbuntu%E7%B3%BB%E7%BB%9F%E9%80%9A%E8%BF%87SSH%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%95%99%E7%A8%8B/"/>
    <url>/omcat.github.io/2026/02/21/WSL%E5%92%8C%E8%BF%9C%E7%A8%8BUbuntu%E7%B3%BB%E7%BB%9F%E9%80%9A%E8%BF%87SSH%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="WSL和远程Ubuntu系统通过SSH连接的教程"><a href="#WSL和远程Ubuntu系统通过SSH连接的教程" class="headerlink" title="WSL和远程Ubuntu系统通过SSH连接的教程"></a>WSL和远程Ubuntu系统通过SSH连接的教程</h1><ul><li>首先，进入到用户目录并查看是否有.ssh文件夹及其对应config文件</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ruby">(base) tangkun<span class="hljs-variable">@LAPTOP</span>-<span class="hljs-variable constant_">F8G6GB8F</span><span class="hljs-symbol">:~</span><span class="hljs-variable">$ </span>cd .ssh<br>(base) tangkun<span class="hljs-variable">@LAPTOP</span>-<span class="hljs-variable constant_">F8G6GB8F</span><span class="hljs-symbol">:~/</span>.ssh<span class="hljs-variable">$ </span>ll<br></code></pre></td></tr></table></figure><ul><li>然后，编辑对应的ssh config文件，设定远程设备名称及其ip，ip可以通过在远程设备命令行执行ifconfig查看</li></ul><p>例如下面的config内容：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">Host <span class="hljs-string">&quot;l20-1&quot;</span><br>     Hostname <span class="hljs-string">&quot;10.15.2.77&quot;</span><br>     <span class="hljs-keyword">User</span> <span class="hljs-title">user</span><br>     IdentityFile ~/.ssh/id_rsa<br>     PubkeyAuthentication yes<br></code></pre></td></tr></table></figure><ul><li><p>然后在远程机器命令行执行sudo apt-get install openssh-server</p></li><li><p>执行ssh xxx（这里的xxx代表User后面的远程名称），如果表示没有安装远程密钥，就执行下面的命令给远程设备安装本机远程控制的密钥：</p></li></ul><p><code>ssh-copy-id user@10.7.153.60</code>（后面的数字代表远程设备的ip地址）</p><ul><li><p>最后就可以执行ssh xxx来连接远程设备工作了。</p></li><li><p>其他命令：</p><p>远程传输文件到本地：</p><ol><li><p>在本地文件夹下打开wsl终端</p></li><li><p>执行示例：<code>scp l20-3:/home/user/document/tangkun/CatESP/opt_freq_xtb_gjfs_logs.tar.gz ./</code></p></li></ol></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/omcat.github.io/2026/02/21/ubuntu%E8%BF%9B%E5%85%A5%E7%BB%88%E7%AB%AF%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6%E6%95%99%E7%A8%8B/"/>
    <url>/omcat.github.io/2026/02/21/ubuntu%E8%BF%9B%E5%85%A5%E7%BB%88%E7%AB%AF%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="ubuntu进入终端复制文件教程"><a href="#ubuntu进入终端复制文件教程" class="headerlink" title="ubuntu进入终端复制文件教程"></a>ubuntu进入终端复制文件教程</h1><ol><li><p>先在启动时按ctrl+alt+f3进入终端</p></li><li><p>输入用户名密码</p></li><li><p>插入U盘设备</p></li><li><p>输入lsblk命令查看系统的磁盘，例如插的U盘是&#x2F;dev&#x2F;sdc，下面分区有sdc1和sdc2</p></li><li><p>输入df -h查看已挂载硬盘挂载点，一般需要手动挂载</p></li><li><p>手动挂载命令：<br>sudo mkdir -p &#x2F;mnt&#x2F;usb #创建挂载目录<br>sudo mount &#x2F;dev&#x2F;sdb1 &#x2F;mnt&#x2F;usb #挂载磁盘<br>挂载成功后，磁盘目录就是<br>&#x2F;mnt&#x2F;usb</p></li><li><p>复制文件：<br>cp &#x2F;文件名 &#x2F;mnt&#x2F;usb&#x2F;</p></li><li><p>取消挂载：</p><p>sudo umount &#x2F;mnt&#x2F;usb</p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/omcat.github.io/2026/02/21/IGMH%E5%88%86%E6%9E%90%E6%B5%81%E7%A8%8B/"/>
    <url>/omcat.github.io/2026/02/21/IGMH%E5%88%86%E6%9E%90%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="IGMH分析流程"><a href="#IGMH分析流程" class="headerlink" title="IGMH分析流程"></a>IGMH分析流程</h1><h2 id="Multiwfn输出cub"><a href="#Multiwfn输出cub" class="headerlink" title="Multiwfn输出cub"></a>Multiwfn输出cub</h2><p>输入文件格式：<br>linux命令行输入 formchk xxx.chk，然后该目录下会输出fch文件，这是其他软件可以读取的非二进制chk文件格式；</p><p>Gaussian中可以在route section加上output&#x3D;wfn，并在分子结构部分末尾空一行写上wfn文件输出路径即可输出.wfn文件，也可以作为Multiwfn的输入文件。</p><p>下面就是做IGMH计算了：<br>启动Multiwfn，然后输入<br>xxx.fch 或者 xxx.wfn<br>20  &#x2F;&#x2F;弱相互作用可视化分析<br>11  &#x2F;&#x2F;IGMH<br>2  &#x2F;&#x2F;定义两个片段<br>1-3,25,32-34,69  &#x2F;&#x2F;第一个片段里的序号，此例对应中心分子序号<br>c  &#x2F;&#x2F;所有其余原子作为第二个片段，等同于输入4-24,26-31,35-68,70-88<br>11  &#x2F;&#x2F;格点设置方式为：选中一批原子，在其四周扩展一定距离定义盒子（即格点分布区域），并指定格点间距。这种模式设置格点最适合当前情况<br>1-3,25,32-34,69  &#x2F;&#x2F;盒子所围绕的中心分子中的原子序号<br>2 A  &#x2F;&#x2F;在中心分子四周扩展2埃定义盒子，通常这足够大了（如果最终从IGMH图中发现有些等值面被截断，可以再加大）<br>0.15  &#x2F;&#x2F;格点间距（Bohr）。越小等值面越光滑，而计算耗时越高。鉴于当前体系较小，耗时必定不高，所以用了这样很精细的格点以得到尽可能理想的图像</p><p>算完后在后处理菜单选择3将格点数据导出成当前目录下的cub文件，然后将其中的dg_inter.cub和sl2r.cub挪到VMD目录下，也把Multiwfn文件包里的examples目录下的IGM_inter.vmd脚本挪到VMD目录下。启动VMD，然后输入<code>source IGM_inter.vmd</code>，即看到下图中δg_inter为0.01的图，此图中等值面上的蓝色部分将所有的氢键作用区域都很好地展现了出来。若进入Graphics - Representation，点击其中第二项，把Isovalue从0.1改小为0.004，看到的就是下图右侧的图，可见此图中绿色扁片部分把相对较弱的范德华作用区域也给展现了出来。</p><h2 id="VMD可视化美化调整"><a href="#VMD可视化美化调整" class="headerlink" title="VMD可视化美化调整"></a>VMD可视化美化调整</h2><ol><li><p>Display先选择Orthographic方式</p></li><li><p>先点击Graphics–&gt;Representations，选择对应Style栏调整Coloring Method，在下拉框中选择以Element类型着色，此时是默认的原子颜色。此外，在该界面可以在Style栏选择Isosurface，这就是相互作用的着色实体，在下面的Material下拉框选择Transparent</p></li><li><p>如果对默认原子类型的颜色不满意，可以点击Graphics–&gt;Colors，在Catagories中选择Element定义特定类型原子的颜色。</p></li></ol><p>最后，就可以实现<a href="http://bbs.keinsci.com/forum.php?mod=viewthread&tid=43122&highlight=IGMH%E7%9A%84%E7%BB%98%E5%9B%BE%E6%95%88%E6%9E%9C%E4%BA%86%E3%80%82">http://bbs.keinsci.com/forum.php?mod=viewthread&amp;tid=43122&amp;highlight=IGMH的绘图效果了。</a></p><p>教程：<a href="http://sobereva.com/621">http://sobereva.com/621</a></p><p>VMD命令：source IGM_inter.vmd</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/omcat.github.io/2026/02/21/IBOView%E5%88%86%E6%9E%90%E6%95%99%E7%A8%8B/"/>
    <url>/omcat.github.io/2026/02/21/IBOView%E5%88%86%E6%9E%90%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="IBOView分析教程"><a href="#IBOView分析教程" class="headerlink" title="IBOView分析教程"></a>IBOView分析教程</h1><h2 id="计算指南"><a href="#计算指南" class="headerlink" title="计算指南"></a>计算指南</h2><p>IBOView的指南在官网上基本写得很全了，软件可视化建议直接下载windows版本来画图，波函数文件建议采用gaussian计算好之后再导入。</p><p><a href="http://iboview.org/_bldUPAt.html">http://iboview.org/_bldUPAt.html</a> 使用Gaussian计算波函数就是一次单点能计算任务，在优化好的结构基础上做。route section命令需要采用官方推荐的<code>#p gfinput IOP(6/7=3) b3lyp/Def2TZVP geom=connectivity</code></p><h2 id="格式转换"><a href="#格式转换" class="headerlink" title="格式转换"></a>格式转换</h2><p>Gaussian计算完成之后输出的.chk文件需要进行如下转换，最终导出为IBOView可以识别的.molden文件。工具为Sob的Multiwfn</p><p>Multiwfn格式转换教程：<a href="http://sobereva.com/379">http://sobereva.com/379</a></p><blockquote><p>Multiwfn的主功能100里的子功能2可以把载入的文件转化成各种格式，目前能输出的格式包括mwfn、pdb、xyz、chg、wfn、wfx、molden、fch、wfn。还能输出47文件，这是独立的NBO程序（即GENNBO）的输入文件。还能输出带有当前原子坐标的各种主流量子化学程序（如Gaussian、GAMESS-US、Molpro、Molcas、ORCA、Dalton等等）和第一性原理程序（CP2K、Quantum ESPRESSO、VASP）的输入文件。如果Multiwfn载入的文件包含基函数信息，那么生成的GAMESS-US、Dalton和Gaussian输入文件里还可以带着初猜波函数信息。Multiwfn的产生ORCA、CP2K、PSI4输入文件的功能尤为强大和重要</p></blockquote><ol><li>将chk文件转换为fchk非二进制格式文件：直接命令行执行：formchk xxx.chk</li><li>启动Multiwfn将fchk转换为molden：启动Multiwfn之后输入xxx.fchk的路径，输入100-2-6，然后enter就可以导出.molden文件了</li><li>使用IBOView画图</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/omcat.github.io/2026/02/21/Gaussian%E7%A8%8B%E5%BA%8FGPU4pyscf%E6%8E%A5%E5%8F%A3%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <url>/omcat.github.io/2026/02/21/Gaussian%E7%A8%8B%E5%BA%8FGPU4pyscf%E6%8E%A5%E5%8F%A3%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="Gaussian程序GPU4pyscf接口安装及使用指南"><a href="#Gaussian程序GPU4pyscf接口安装及使用指南" class="headerlink" title="Gaussian程序GPU4pyscf接口安装及使用指南"></a>Gaussian程序GPU4pyscf接口安装及使用指南</h1><h2 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法"></a>安装方法</h2><p>首先安装好pyscf环境 (<a href="https://pyscf.org/user/install.html)%EF%BC%9A">https://pyscf.org/user/install.html)：</a></p><ol><li><code>conda create -n pyscf python=3.10</code></li><li><code>pip install --prefer-binary pyscf</code></li></ol><p>然后安装GPU4pyscf</p><ol><li><p>先要检查本机的CUDA版本，需要安装CudaToolkit查看，命令为：<code>nvcc -version</code>，nvidia -smi的cuda版本并不是真实的版本，而是指的是当前cuda能够最高支持的版本。</p></li><li><p>安装GPU4pyscf <a href="https://pyscf.org/user/gpu.html%EF%BC%9A">https://pyscf.org/user/gpu.html：</a></p><p><code>pip3 install gpu4pyscf-cuda12x</code></p><p><code>pip3 install cutensor-cu12</code></p></li></ol><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>直接在gjf中定义好接口，然后g16运行，参考gpu4pyscf-test.gjf</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/omcat.github.io/2025/02/21/hello-world/"/>
    <url>/omcat.github.io/2025/02/21/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>NavicatGA学习笔记</title>
    <link href="/omcat.github.io/2025/02/21/NavicatGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/omcat.github.io/2025/02/21/NavicatGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="NavicatGA学习笔记"><a href="#NavicatGA学习笔记" class="headerlink" title="NavicatGA学习笔记"></a>NavicatGA学习笔记</h1><h2 id="框架摘要"><a href="#框架摘要" class="headerlink" title="框架摘要"></a>框架摘要</h2><ul><li>该库分为GA基础父类求解器和好几种不同分子表示方式的GA子类求解器（<strong>selfies_solver、smiles_solver、xyz_solver</strong>，分别对应基于selfies、smiles和AaronTools的二维和三维分子结构表示方法）</li><li>其他类包含“封装器”和“化学模块”，封装器是很多个定义的常用用化学性质预测函数（如前线分子轨道能量、分子体积），包含依赖于pyscf来解决电子结构问题的功能，这些都可以用作<strong>适应度函数</strong>，可以很方便地自定义。</li><li>chimera模块(<a href="https://github.com/aspuru-guzik-group/chimera)%E8%A2%AB%E7%94%A8%E4%BA%8E%E6%A0%87%E9%87%8F%E5%8C%96%EF%BC%8C%E5%9C%A8%E6%B1%82%E8%A7%A3%E5%A4%9A%E7%9B%AE%E6%A0%87%E8%AE%BE%E8%AE%A1%E6%A1%88%E4%BE%8B%E6%97%B6%E7%94%A8%E5%88%B0%E3%80%82">https://github.com/aspuru-guzik-group/chimera)被用于标量化，在求解多目标设计案例时用到。</a></li></ul><h2 id="安装注意"><a href="#安装注意" class="headerlink" title="安装注意"></a>安装注意</h2><p>不要使用原说明文档中的安装指令，直接cd到源代码目录然后使用pip install . 安装。最后在使用过程总可能会缺少依赖库，挨个安装即可。</p><p>修改源代码的时候，可以在import开头写上：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python3</span><br><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><span class="hljs-keyword">import</span> sys<br>sys.path.insert(<span class="hljs-number">0</span>, <span class="hljs-string">&#x27;./navicatGA&#x27;</span>)<br></code></pre></td></tr></table></figure><p>这样可以实现导入的函数和类是从当前测试路径下的源代码来的，可以直接修改该路径下的源代码从而构建自己的修改版本。</p><h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><h3 id="整体概述"><a href="#整体概述" class="headerlink" title="整体概述"></a>整体概述</h3><ul><li>给定初始种群基因，可以是二维的smiles，也可以是scaffold三维结构。种群中的每一个个体都可以称之为染色体，而每个染色体的组成部分则可以称之为基因，基因就是我们的最基础的设计单元；</li><li><u>组装器和适应度函数</u>：组装器将基因片段组合成为染色体，也就是设计出的催化剂个体，适应度函数则将组装器生成的个体作为输入参数，并返回对应的适应度函数数值（一般是经过归一化处理，在0~1之间），优化器会尝试最大化适应度函数；</li><li><u>适应度函数</u>：适应度函数会根据具体的应用案例变化，作用是将候选催化剂的化学结构映射到其在给定反应中的性能指标，例如<strong>分子火山图</strong>方法；</li><li>逐代进行交叉、变异，然后适应度函数评估，直至设计出适应度最佳的催化剂结构。</li></ul><p><img src="C:\Users\TangKun\AppData\Roaming\Typora\typora-user-images\image-20250217203053805.png" alt="image-20250217203053805"></p><ul><li>图中的<strong>Scalarization</strong>操作意思是标量化，Chimera在NaviCat-GA中充当多目标优化的标量化器，其主要功能是将多个优化目标的结果综合评估为一个单一的适应度值。具体来说，用户可以通过为每个优化目标分配优先级和降级阈值来定制优化策略，Chimera则基于这些设定，评估候选解在种群中的相对表现，最终生成一个代表整体优化效果的得分。此外，Chimera能够有效平衡各优化目标之间的冲突，使得在遗传算法中能够更高效地进行多目标优化。（<em>每当需要优化多个属性时，通常会在两个或多个目标之间进行权衡，从而阻止最优解的存在。在这种情况下，可以根据决策者选择的标准来识别优化问题的大量解决方案，即所谓的帕累托前沿。</em>）主要有两种操作方式：①用户通过为不同的属性分配权重（例如，最终适应度选择性占60%，活性占40%），或使用阶跃函数定义硬边界（例如，当选择性降至某个值以下时，将适应度设为0），对优化问题施加选定的标准。</li></ul><p>选择策略有以下几种：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">allowed_selection_strategies = &#123;<br>    <span class="hljs-string">&quot;roulette_wheel&quot;</span>,<br>    <span class="hljs-string">&quot;two_by_two&quot;</span>,<br>    <span class="hljs-string">&quot;random&quot;</span>,<br>    <span class="hljs-string">&quot;tournament&quot;</span>,<br>    <span class="hljs-string">&quot;boltzmann&quot;</span>,<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="GenAlgSolver类的框架和原理详细解析"><a href="#GenAlgSolver类的框架和原理详细解析" class="headerlink" title="GenAlgSolver类的框架和原理详细解析"></a><code>GenAlgSolver</code>类的框架和原理详细解析</h3><h2 id="关于分子火山图volcano-plot"><a href="#关于分子火山图volcano-plot" class="headerlink" title="关于分子火山图volcano plot"></a>关于分子火山图volcano plot</h2><p>github地址：<a href="https://github.com/lcmd-epfl/volcanic">https://github.com/lcmd-epfl/volcanic</a></p><p>论文：<a href="https://doi.org/10.1038/s41596-022-00726-2">https://doi.org/10.1038/s41596-022-00726-2</a></p><h3 id="构建方式"><a href="#构建方式" class="headerlink" title="构建方式"></a>构建方式</h3><ul><li><p>论文方法</p><ul><li>使用密度泛函理论（DFT）计算催化循环的相对自由能。</li><li>根据线性自由能尺度关系（LFESRs），选择适当的描述变量（通常为某中间体的相对自由能）。</li><li>构建起伏曲线关系（SRP），并通过最小值提取法生成火山图。</li></ul></li><li><p>步骤</p><ol><li>确定催化机制，优化中间态和过渡态的几何结构。</li><li>选择一个具有电子和空间多样性的催化剂池（10-50种催化剂）。</li><li>获取所有催化循环中间态和过渡态的相对自由能数据。</li><li>确定线性缩 放关系，并选择最佳描述变量。</li><li>构建起伏曲线关系（SRP）和火山图。</li><li>（可选）生成转换频率（TOF）火山图。</li></ol></li><li><p>自动化工具</p><ul><li>提供了“volcanic” Python包，用于自动化火山图和活动图的构造过程。</li></ul></li></ul><h3 id="线性缩放关系-（LFESRs）"><a href="#线性缩放关系-（LFESRs）" class="headerlink" title="线性缩放关系**（LFESRs）**"></a>线性缩放关系**（LFESRs）**</h3><p>线性缩放关系是指描述变量（descriptor variable）与其他中间体或过渡态的相对自由能（ΔG_RRS）之间的线性关系。这些关系是构建火山图和活动图的基础。</p><p>论文中指出，线性缩放关系的存在是因为不同的中间体或过渡态之间的能量变化具有规律性。例如，某个中间体的自由能变化可以通过另一个中间体的自由能变化来线性预测。</p><p><img src="C:\Users\TangKun\AppData\Roaming\Typora\typora-user-images\image-20250217210645880.png" alt="image-20250217210645880"></p><h4 id="1-如何确定线性缩放关系？"><a href="#1-如何确定线性缩放关系？" class="headerlink" title="1. 如何确定线性缩放关系？"></a><strong>1. 如何确定线性缩放关系？</strong></h4><p><strong>绘制自由能对比图</strong></p><ul><li>对于每个催化剂，计算出催化循环中所有中间体和过渡态的相对自由能（ΔG_RRS）。</li><li>将每个中间体的自由能与其他中间体&#x2F;过渡态的自由能进行对比，绘制自由能对自由能的散点图。</li></ul><!--例如：在Suzuki-Miyaura反应中，论文中提到，ΔG_RRS(Int2)（某中间体的自由能）可以与ΔG_RRS(TS1)（某过渡态的自由能）进行对比，查看是否存在线性关系。--><p><strong>进行线性回归</strong></p><ul><li>对每对中间体&#x2F;过渡态的自由能数据，进行线性回归（ordinary least squares, OLS）。</li><li>计算回归的质量指标，例如：<ul><li><strong>决定系数（R²）</strong>：衡量线性关系的拟合程度，R²越接近1，线性关系越好。</li><li>**平均绝对误差（MAE）**和**平均绝对百分比误差（MAPE）**：衡量回归误差的大小。</li></ul></li></ul><p><strong>选择最佳描述变量</strong></p><ul><li>根据回归质量指标，选择一个中间体的自由能作为描述变量（descriptor variable）。</li><li>通常，选择与其他中间体&#x2F;过渡态具有最高R²值、最低MAE和MAPE的中间体自由能作为描述变量。</li></ul><h4 id="2-实际案例：Suzuki-Miyaura反应"><a href="#2-实际案例：Suzuki-Miyaura反应" class="headerlink" title="2. 实际案例：Suzuki-Miyaura反应"></a>2. <strong>实际案例：Suzuki-Miyaura反应</strong></h4><p>在论文中，作者以Suzuki-Miyaura反应为例，具体描述了如何确定线性缩放关系和选择描述变量。</p><p><strong>描述变量的选择</strong></p><ul><li>催化循环包括多个中间体（Int1, Int2, etc.）和过渡态（TS1, TS2, etc.）。</li><li>通过线性回归分析，发现ΔG_RRS(Int2)（某中间体的自由能）与其他中间体&#x2F;过渡态的自由能具有最好的线性关系（R²&#x3D;0.8211）。</li><li>因此，ΔG_RRS(Int2)被选为描述变量。</li></ul><p><strong>线性缩放关系的构建</strong></p><ul><li>使用ΔG_RRS(Int2)作为描述变量，构建与其他中间体&#x2F;过渡态的自由能关系。</li><li>示例：ΔG_RRS(TS1) &#x3D; A × ΔG_RRS(Int2) + b，其中A是斜率，b是截距。</li></ul><h4 id="3-如何验证描述变量的选择？"><a href="#3-如何验证描述变量的选择？" class="headerlink" title="3. 如何验证描述变量的选择？"></a>3. <strong>如何验证描述变量的选择？</strong></h4><ul><li><strong>回归质量指标</strong>：确保描述变量与其他中间体&#x2F;过渡态的自由能具有高R²值和低误差。</li><li><strong>化学意义</strong>：描述变量应对应于催化循环中对活性有重要影响的中间体。</li><li><strong>预测能力</strong>：通过火山图预测催化剂的活性，并与实验数据进行对比验证。</li></ul><h4 id="4-如果没有明显的线性关系怎么办？"><a href="#4-如果没有明显的线性关系怎么办？" class="headerlink" title="4. 如果没有明显的线性关系怎么办？"></a>4. <strong>如果没有明显的线性关系怎么办？</strong></h4><p>如果线性缩放关系较差，可能是因为：</p><ol><li><strong>催化剂池不够多样化</strong>：增加催化剂池的多样性（电子效应和空间效应）。</li><li><strong>描述变量的选择不当</strong>：尝试其他中间体&#x2F;过渡态的自由能作为描述变量。</li><li><strong>催化机制复杂</strong>：可能需要引入第二个描述变量，构建活动图（multi-dimensional analysis）。</li></ol><h2 id="与GB-GA基于图的遗传算法的对比"><a href="#与GB-GA基于图的遗传算法的对比" class="headerlink" title="与GB-GA基于图的遗传算法的对比"></a>与GB-GA基于图的遗传算法的对比</h2><h3 id="为什么称为“基于图的遗传算法”（GB-GA）？"><a href="#为什么称为“基于图的遗传算法”（GB-GA）？" class="headerlink" title="为什么称为“基于图的遗传算法”（GB-GA）？"></a><strong>为什么称为“基于图的遗传算法”（GB-GA）？</strong></h3><p>论文中的遗传算法被称为“基于图的遗传算法”（Graph-Based Genetic Algorithm, GB-GA），是因为其核心操作直接作用于<strong>分子图结构</strong>（而非传统的字符串或向量表示）。分子图以原子为节点、化学键为边，保留了分子的拓扑结构和化学键信息，避免了传统基于SMILES字符串的遗传算法（如交叉和变异可能生成无效结构）的局限性。</p><hr><h3 id="与传统GA相比的优势"><a href="#与传统GA相比的优势" class="headerlink" title="与传统GA相比的优势"></a><strong>与传统GA相比的优势</strong></h3><p>传统遗传算法（GA）在分子优化中通常基于SMILES字符串或固定长度的向量表示，而GB-GA的优势主要体现在以下方面：</p><table><thead><tr><th align="center"><strong>对比维度</strong></th><th align="center"><strong>传统GA（如基于SMILES）</strong></th><th align="center"><strong>基于图的GA（GB-GA）</strong></th></tr></thead><tbody><tr><td align="center"><strong>表示方式</strong></td><td align="center">SMILES字符串（线性序列）</td><td align="center">分子图（节点&#x3D;原子，边&#x3D;化学键）</td></tr><tr><td align="center"><strong>化学合理性</strong></td><td align="center">交叉&#x2F;变异易生成无效SMILES，需额外验证</td><td align="center">直接在化学规则下操作，保证分子有效性</td></tr><tr><td align="center"><strong>结构灵活性</strong></td><td align="center">难以处理环状结构或复杂键合关系</td><td align="center">天然支持环、支链、多键等复杂结构</td></tr><tr><td align="center"><strong>优化效率</strong></td><td align="center">需频繁修复无效分子，计算开销大</td><td align="center">无需后处理，计算速度更快（论文中30秒&#x2F;次）</td></tr><tr><td align="center"><strong>化学空间探索</strong></td><td align="center">受限于SMILES语法，多样性较低</td><td align="center">通过子图交换直接探索新结构，多样性更高</td></tr></tbody></table><p><strong>核心优势总结</strong>：</p><ol><li><strong>分子有效性</strong>：交叉和变异操作基于化学规则（如价键规则），避免生成无效分子。</li><li><strong>计算高效性</strong>：省去无效结构的修复步骤，显著缩短优化时间。</li><li><strong>复杂结构支持</strong>：直接操作图结构，更适用于含环、多支链的分子优化。</li></ol><h3 id="基于分子图的遗传算法如何表示分子？"><a href="#基于分子图的遗传算法如何表示分子？" class="headerlink" title="基于分子图的遗传算法如何表示分子？"></a><strong>基于分子图的遗传算法如何表示分子？</strong></h3><p>在论文中，分子图通过以下方式表示和操作：</p><h4 id="1-分子图数据结构"><a href="#1-分子图数据结构" class="headerlink" title="1. 分子图数据结构"></a><strong>1. 分子图数据结构</strong></h4><ul><li><strong>节点（Atoms）</strong>：每个节点表示一个原子，附带属性（如原子类型、电荷等）。</li><li><strong>边（Bonds）</strong>：每条边表示化学键，附带键类型（单键、双键等）。</li><li><strong>实现工具</strong>：基于RDKit库将分子转换为图对象，确保化学规则的兼容性。</li></ul><h4 id="2-遗传操作设计"><a href="#2-遗传操作设计" class="headerlink" title="2. 遗传操作设计"></a><strong>2. 遗传操作设计</strong></h4><ul><li><strong>交叉（Crossover）</strong>：<br>选择两个父代分子，交换它们的子图（如随机选择一个公共子结构或键进行交换），生成新子代。<br><strong>示例</strong>：若两个分子均含苯环，可交换苯环上的取代基。</li><li><strong>变异（Mutation）</strong>：<br>对单个分子进行局部修改，包括：<ul><li><strong>原子替换</strong>：更改某个原子的类型（如C→N）。</li><li><strong>键修改</strong>：调整键的类型（如单键→双键）或添加&#x2F;删除键。</li><li><strong>子结构替换</strong>：用预定义片段（如-OH、-NH₂）替换原有子结构。</li></ul></li></ul><h4 id="3-论文中的具体实现"><a href="#3-论文中的具体实现" class="headerlink" title="3. 论文中的具体实现"></a><strong>3. 论文中的具体实现</strong></h4><ul><li><strong>初始种群</strong>：从ZINC250k数据集中随机选取分子作为初始种群。</li><li><strong>适应度函数</strong>：以惩罚后的log P值为目标（<code>J(m) = log P(m) - SA(m) - RingPenalty(m)</code>）。</li><li><strong>选择策略</strong>：采用锦标赛选择（Tournament Selection），保留高适应度个体。</li><li><strong>终止条件</strong>：设定固定进化代数（如50代）或收敛阈值。</li></ul><hr><h3 id="为什么GB-GA在论文中表现更优？"><a href="#为什么GB-GA在论文中表现更优？" class="headerlink" title="为什么GB-GA在论文中表现更优？"></a><strong>为什么GB-GA在论文中表现更优？</strong></h3><p>论文通过实验验证了GB-GA的优越性，主要原因包括：</p><ol><li><strong>直接操作化学结构</strong>：避免SMILES的语法约束，生成更多样且复杂的分子。</li><li><strong>高效探索化学空间</strong>：通过子图交换和局部变异，快速发现高log P值的结构（如扩展共轭体系或引入疏水基团）。</li><li><strong>低计算成本</strong>：无需GPU加速，单次优化仅需30秒，适合资源有限场景。</li></ol><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>GB-GA通过<strong>分子图表示</strong>和<strong>化学规则驱动的遗传操作</strong>，解决了传统GA在分子生成中的无效结构问题和探索效率瓶颈。其优势在于<strong>化学直观性</strong>、<strong>高效性</strong>和<strong>多样性</strong>，特别适用于需快速探索复杂化学空间的优化任务（如log P值最大化）。论文通过对比实验，验证了其在特定场景下优于机器学习方法的潜力。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>遗传算法</tag>
      
      <tag>化学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Q2MM(TSFF)方法的细节与实现原理</title>
    <link href="/omcat.github.io/2025/02/21/Q2MM(TSFF)%E6%96%B9%E6%B3%95%E7%9A%84%E7%BB%86%E8%8A%82%E4%B8%8E%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <url>/omcat.github.io/2025/02/21/Q2MM(TSFF)%E6%96%B9%E6%B3%95%E7%9A%84%E7%BB%86%E8%8A%82%E4%B8%8E%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Q2MM-TSFF-方法的细节与实现原理"><a href="#Q2MM-TSFF-方法的细节与实现原理" class="headerlink" title="Q2MM(TSFF)方法的细节与实现原理"></a>Q2MM(TSFF)方法的细节与实现原理</h1><p>TSFF力场由来已久，早期的科研人员通过传统的分子力场方法直接应用到反应过渡态的方式进行反应动力学研究。Q2MM是一种经过Per-Ola Norrby课题组经过长达二十多年开发形成的全新具有高度实用价值的过渡态力场方法，目前已经被集成到ACE（Asymmetric catalytic evaluation）和CatVS（Catalyst virtual screening）这两个全自动化均相催化剂虚拟筛选软件之中，相关论文发表于Nat. Catalysis，JACS，JCC，Chem. Sci. 等期刊。</p><p>![1c07abea3fa047817db72a78c606ade](E:\Softwares\WeChat\WeChat Files\wxid_mw2n7uz79zg222\FileStorage\Temp\1c07abea3fa047817db72a78c606ade.png)</p><p>TSFF（过渡态力场，Transition State Force Field）方法是专门为准确预测化学反应中的过渡态能量而开发的。传统的力场方法（如分子力学）主要用于预测分子在平衡状态下的几何结构和相对稳定的构象转变。然而，传统力场通常不适用于反应中的键断裂或形成过程，因为这些过程涉及显著的几何变形和势能面的复杂变化。</p><p>TSFF方法的核心创新在于，将过渡态视为势能面的局部极小值，并通过重新构建力场参数，使得过渡态几何结构可以通过最小化能量直接获得(2003_TSFF过渡态力场的原理)。与常规力场方法不同，TSFF不依赖反应物和产物的势能面，而是直接将过渡态的几何信息融入力场中。这种方法不仅能够有效捕捉过渡态的能量，还能准确预测类似反应的相对反应性和选择性。</p><h2 id="TSFF的原理"><a href="#TSFF的原理" class="headerlink" title="TSFF的原理"></a>TSFF的原理</h2><h3 id="力场参数的回归流程"><a href="#力场参数的回归流程" class="headerlink" title="力场参数的回归流程"></a>力场参数的回归流程</h3><p><img src="C:\Users\TangKun\AppData\Roaming\Typora\typora-user-images\image-20241030101850260.png" alt="image-20241030101850260"></p><h3 id="过渡态结构优化上的巧思"><a href="#过渡态结构优化上的巧思" class="headerlink" title="过渡态结构优化上的巧思"></a>过渡态结构优化上的巧思</h3><p>TSFF拟合需要QM计算得到的精确过渡态的结构以及其对应的Hessian矩阵，这里对标签值中的Hessian矩阵进行了修改，将Hessian矩阵对角化之后得到的特征值中的唯一的负值改成了+1（一个相对较大的正特征值），这样做会使得过渡态沿着反应路径（MEP）的势能面的曲率反转变成正值，从可视化角度看就是势能面进行了翻转，如下图所示，原先过渡态上的鞍点变成了极小点，这样操作之后，就可以采用最小化优化算法来优化过渡态结构了。</p><p><img src="C:\Users\TangKun\AppData\Roaming\Typora\typora-user-images\image-20241030102428789.png" alt="image-20241030102428789"></p><!--补充知识1：E对R求二阶偏导数得到维度为(3*N，3*N)的Hessian矩阵，Hessian中的每一个元素都是关于两个不同原子坐标的能量的导数，其中对角元素是每个原子自身坐标关于能量的二阶偏导数，因此在使用Hessian时一般只需要上或者下三角阵即可包含全部所需的信息--><!--补充知识2：Hessian对角化操作可以求出特征值和特征向量，特征值对应分子系统中原子与原子之间的振动频率，特征向量对应振动方向及振幅 。特征值全部为正代表曲率为正，坐标不论怎么改变，不论向着什么方向，能量都会升高，这对应着势能面上的谷底（极小点）；特征值除了反应坐标方向为负值（曲率为负值，也是唯一的虚频的来源，参见下面的公式），其余都为正，这对应着过渡态，也就是势能面上的鞍点，因为这个点上的结构只有沿着反应坐标变化能量才会降低，而其他所有方向都会升高--><!--振动频率ω可以通过下面的公式计算，其中λ是特征值，μ是约化质量。--><p>$$<br>\omega&#x3D;\sqrt{\frac{1}{\mu}\lambda}<br>$$</p><h3 id="Hessian标签数据处理方式"><a href="#Hessian标签数据处理方式" class="headerlink" title="Hessian标签数据处理方式"></a>Hessian标签数据处理方式</h3><ul><li><p>首先通过QM做频率分析计算得到Hessian矩阵</p></li><li><p>对Hessian矩阵进行对角化得到特征值特征向量</p></li><li><p>将唯一的负特征值改为(+1)</p></li><li><p>根据修改之后的特征向量和特征值还原出新的Hessian</p></li><li><p>以新的Hessian拟合力场参数<br>$$<br>H&#x3D;X^TDX<br>$$</p><p>$$<br>\mathsf{H}^{\prime}&#x3D;\mathbf{X}^{\mathsf{T}}\mathbf{D}^{\prime}\mathbf{X}<br>$$</p><p>$$<br>\mathbf{D}&#x3D;\begin{bmatrix}-\lambda_1&amp;&amp;\cdots&amp;&amp;\mathbf{0}\\&amp;\mathbf{0}&amp;&amp;&amp;\\\vdots&amp;&amp;\lambda_\mathbf{8}&amp;&amp;\vdots\\&amp;&amp;&amp;\ddots&amp;\\\mathbf{0}&amp;\cdots&amp;&amp;&amp;\lambda_N\end{bmatrix}\quad\mathbf{D}^{\prime}&#x3D;\begin{bmatrix}+\mathbf{1}&amp;&amp;\cdots&amp;&amp;\mathbf{0}\\&amp;\mathbf{0}&amp;&amp;&amp;\\\vdots&amp;&amp;\lambda_\mathbf{\Phi}&amp;&amp;\vdots\\&amp;&amp;&amp;\ddots&amp;\\\mathbf{0}&amp;\cdots&amp;&amp;&amp;\lambda_N\end{bmatrix}<br>$$</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-comment"># 对角化Hessian矩阵</span><br>eigenvalues, eigenvectors = np.linalg.eig(hessian_matrix)<br></code></pre></td></tr></table></figure><h2 id="TSFF的发展以及拟合的注意事项"><a href="#TSFF的发展以及拟合的注意事项" class="headerlink" title="TSFF的发展以及拟合的注意事项"></a>TSFF的发展以及拟合的注意事项</h2><h3 id="关于Hessian的拟合"><a href="#关于Hessian的拟合" class="headerlink" title="关于Hessian的拟合"></a>关于Hessian的拟合</h3><p>TSFF拟合过程中惩罚函数是预测值与标签值之间的平方误差之和，最开始的工作中为了区分分别与键角、扭转、长程作用相关的Hessian元素，对惩罚函数中的平方误差和采用了加权因子缩放[Hagler and coworkers]。后续的更新版本TSFF去掉了加权因子缩放操作，直接拟合原始Hessian。</p><p>连接同一原子上两个坐标的Hessian元素，块对角元素，并不直接对应于力场相互作用，而是包含冗余数据。块对角线元素是非对角线元素的总和，并且倾向于将适当拟合的Hessian元素与可用分子力学函数无法表示的其他元素耦合。因此，通过从参数化过程中排除块对角元素，可以在不损失数据的情况下改进Hessian拟合，称之为“非对角线Hessian拟合”。</p><h2 id="如何采用NFF取代TSFF"><a href="#如何采用NFF取代TSFF" class="headerlink" title="如何采用NFF取代TSFF"></a>如何采用NFF取代TSFF</h2><h2 id="NFF取代TSFF进行催化剂虚拟筛选的尝试"><a href="#NFF取代TSFF进行催化剂虚拟筛选的尝试" class="headerlink" title="NFF取代TSFF进行催化剂虚拟筛选的尝试"></a>NFF取代TSFF进行催化剂虚拟筛选的尝试</h2>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分子力场</tag>
      
      <tag>计算化学</tag>
      
      <tag>过渡态力场</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>有机金属催化反应的过渡态优化技巧</title>
    <link href="/omcat.github.io/2025/02/21/%E5%8E%9F%E5%AD%90%E6%95%B0%E5%A4%A7%E4%BA%8E100%E7%9A%84%E5%A4%8D%E6%9D%82%E4%B8%8D%E5%AF%B9%E7%A7%B0%E6%9C%89%E6%9C%BA%E9%87%91%E5%B1%9E%E5%82%AC%E5%8C%96%E5%8F%8D%E5%BA%94%E7%9A%84%E8%BF%87%E6%B8%A1%E6%80%81%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/"/>
    <url>/omcat.github.io/2025/02/21/%E5%8E%9F%E5%AD%90%E6%95%B0%E5%A4%A7%E4%BA%8E100%E7%9A%84%E5%A4%8D%E6%9D%82%E4%B8%8D%E5%AF%B9%E7%A7%B0%E6%9C%89%E6%9C%BA%E9%87%91%E5%B1%9E%E5%82%AC%E5%8C%96%E5%8F%8D%E5%BA%94%E7%9A%84%E8%BF%87%E6%B8%A1%E6%80%81%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="原子数大于100的复杂不对称有机金属催化反应的过渡态优化方法"><a href="#原子数大于100的复杂不对称有机金属催化反应的过渡态优化方法" class="headerlink" title="原子数大于100的复杂不对称有机金属催化反应的过渡态优化方法"></a>原子数大于100的复杂不对称有机金属催化反应的过渡态优化方法</h1><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><ul><li>如果提前已知反应机理：了解反应机理和反应的实验条件（反应温度、溶剂、压力）；</li><li>未知反应机理：根据猜测分析反应机理，并制定计算分析计划，分步搜索过渡态，最终绘制reaction profile；</li><li>确定过渡态结构优化&#x2F;频率分析和电子能量计算两步骤的泛函，基组&#x2F;赝势基组，色散校正项。</li></ul><h2 id="计算流程"><a href="#计算流程" class="headerlink" title="计算流程"></a>计算流程</h2><ol><li><p>手动建立反应络合体系的过渡态初猜结构；</p></li><li><p>采用Gaussian+GFN2-xTB快速搜索过渡态初猜结构；</p></li><li><p>利用GENConf-TS固定反应位点，基于分子动力学方法，指定温度进行最低能量构象搜索；</p><ul><li><a href="http://bbs.keinsci.com/thread-20063-1-1.html">http://bbs.keinsci.com/thread-20063-1-1.html</a></li><li><a href="http://sobereva.com/165">根据Boltzmann分布计算分子不同构象所占比例</a>：<a href="http://sobereva.com/165">http://sobereva.com/165</a></li><li><a href="http://bbs.keinsci.com/thread-577-1-1.html">http://bbs.keinsci.com/thread-577-1-1.html</a></li><li><a href="http://bbs.keinsci.com/forum.php?mod=viewthread&tid=2388&highlight=gentor">http://bbs.keinsci.com/forum.php?mod=viewthread&amp;tid=2388&amp;highlight=gentor</a></li></ul></li><li><p>基于最低能量构象，重新创建Gaussian的输入文件。对于较大体系，过渡态优化的计算指令可按照如下方式渐进，在有限计算资源下最快找到DFT精度级别的可用过渡态结构：</p><ul><li><p>首先用opt&#x3D;(ts,noeigen,calcfc,recalc&#x3D;3)，或者recalc&#x3D;5成本更低一些；</p></li><li><p>如果不收敛，可尝试opt&#x3D;(ts,noeigen,calcfc,recalc&#x3D;3,maxstep&#x3D;3,notrust)，这样基本大部分都能成功；</p></li><li><p>再进一步，采用opt&#x3D;(ts,noeigen,calcall)，每一步都精确计算Hessian，计算成本最高，但是能够保证不会陷入优化振荡。</p></li><li><p>优化指令的技术解释：</p><p>一般采用的计算精度级别越高，势能面越精确，因此直接采用calcfc命令计算由于Hessian只在第一步计算了精确值，大体系优化到后期容易陷入优化振荡，也就是从optimization中可以看到体系的能量一开始是下降的，但后面优化到两百步以上基本就在反复振荡，难以收敛到精确的鞍点（一般正常收敛150个原子体系需要100+步优化就成功了，步骤更多的基本就是陷入振荡了）。</p><p>这时候，需要采用recalc命令结合calcfc使用，每走n步就重新计算精确Hessian，并结合maxstep调整每一次优化的步长上限来走出势阱。</p><p><em>opt&#x3D;maxstep&#x3D;N（等价于IOp(1&#x2F;8&#x3D;N)）可以将步长上限（也称置信半径）调整到0.01N Bohr或弧度，默认是30。当按照优化方法判断出的下一步几何变量的变化超过这个数值，则实际的改变量会调节到恰好等于这个上限值（具体来说，是在置信半径对应的球面上做最小化寻找最佳的位置）。如果优化发生震荡，且每步位移不是很大而受力较大的话，往往表明优化过程陷在比较深、比较窄的势阱里，此时可以降低步长上限，比如降低到N&#x3D;5乃至N&#x3D;3，以避免每次都走过头而始终达不到势能面极小点。减小步长的做法不要在优化过程中过早地使用，否则由于优化过程走得太慢，所需的优化步数会增加。另外，如果用了calcall，减小步长上限不一定有好处，因为在精确Hessian下进行优化，每一步走的是比较准确的，人为篡改了步长有可能还阻碍收敛。</em></p><p><em>注意，maxstep设的只是最初的步长上限。随着优化的进行，步长上限其实是动态调整的。如果想一直用自己的设定，需要在opt中加上NoTrust关键词。对于结构反复微小震荡的情况，在使用maxstep减小步长上限的同时总建议同时写上此关键词。</em>*</p><p><em>（<a href="http://sobereva.com/164%EF%BC%89">http://sobereva.com/164）</a></em></p></li></ul></li><li><p>限制性优化技巧</p><ul><li>对于GENConf-TS得到的最低能量构象，或者是之前优化未收敛的几何结构，可以提取出来，固定其过渡态反应位点，进行限制性几何结构最小化，最后将最小化结构作为过渡态初猜来用于过渡态的精确搜索。固定反应位点可以采用Gaussview手动操作，教程<a href="http://bbs.keinsci.com/thread-9022-1-1.html%E3%80%82%E5%8F%B3%E9%94%AE%E7%82%B9%E5%87%BB%E9%9C%80%E8%A6%81%E5%86%BB%E7%BB%93%E7%9A%84%E5%8E%9F%E5%AD%90%EF%BC%8C%E9%80%89%E6%8B%A9select%EF%BC%8C%E5%8E%9F%E5%AD%90%E5%8F%98%E4%B8%BA%E9%BB%84%E8%89%B2%EF%BC%8C%E9%80%89%E5%AE%8C%E4%BA%86%E4%B9%8B%E5%90%8E%EF%BC%8C%E8%BF%9B%E5%85%A5Tools">http://bbs.keinsci.com/thread-9022-1-1.html。右键点击需要冻结的原子，选择select，原子变为黄色，选完了之后，进入Tools</a> - Atom Groups，把类别切换到Freeze，然后点击Freeze(Yes)那一行中的+号把选中的区域添加到这个冻结组里。此时体系就被分为冻结和不冻结的两个组了。保存之后发现被冻结的原子会在多出的一列数值中显示为-1，未被冻结的显示为0。</li><li>注意最后限制性优化完成后，复制坐标到TS优化任务的输入文件中要记得取消反应位点冻结。</li></ul></li><li><p>色散校正</p><ul><li><a href="http://sobereva.com/210">http://sobereva.com/210</a></li><li>em&#x3D;gd3bj和em&#x3D;gd3要分开看，有些基组有BJ阻尼的就不要加上bj的关键词。</li></ul></li><li><p>赝势基组</p><ul><li><a href="http://sobereva.com/373">http://sobereva.com/373</a></li></ul></li><li><p>溶剂化模型</p><ul><li><a href="http://sobereva.com/327">http://sobereva.com/327</a></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>经验笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算化学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AARON的安装</title>
    <link href="/omcat.github.io/2025/02/21/AARON%E7%9A%84%E5%AE%89%E8%A3%85/"/>
    <url>/omcat.github.io/2025/02/21/AARON%E7%9A%84%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<ol><li>网上搜索教程安装slurm，以及Perl语言</li><li>安装给给g16</li><li>命令行输入perl -MCPAN -e shell 进入CPAN界面，之后输入install Math::Vector::Real 和 install Math::MatrixReal 安装这两个Perl的库，最后退出CPAN输入quit</li><li>按照教程配置环境变量</li><li>通过Aaron和AaronTools两个.&#x2F;test__full_install.t的测试</li><li>工作目录必须在根目录和QChASM同级</li></ol><p>perldoc -l DBD::mysql 是用来查看Perl已经安装库的命令<br>which perl 可以用来查看是否安装了perl以及安装的位置</p>]]></content>
    
    
    <categories>
      
      <category>量子化学软件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AARON</tag>
      
      <tag>安装</tag>
      
      <tag>Perl</tag>
      
      <tag>Slurm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ChimeraX命令行highlight原子或键</title>
    <link href="/omcat.github.io/2025/02/21/Chimerax%E5%91%BD%E4%BB%A4%E8%A1%8Chighlight%E5%8E%9F%E5%AD%90%E6%88%96%E9%94%AE/"/>
    <url>/omcat.github.io/2025/02/21/Chimerax%E5%91%BD%E4%BB%A4%E8%A1%8Chighlight%E5%8E%9F%E5%AD%90%E6%88%96%E9%94%AE/</url>
    
    <content type="html"><![CDATA[<ol><li>先在right mouse 窗口点击开启select，用鼠标右键选中目标原子或者键，从log中读取其编号，比如#4&#x2F;a:1@Si1，具体含义可以从select命令的说明文档中查看；</li><li>用下面的命令highlight该目标原子或者键：<br>highlight #4&#x2F;a:1@Si1 transparency 50 color rgb(0,255,0) scale 1.5<br>三个参数分别指定highlight的透明度，颜色，大小</li></ol>]]></content>
    
    
    <categories>
      
      <category>工具软件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ChimeraX</tag>
      
      <tag>可视化</tag>
      
      <tag>分子可视化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DCU使用教程</title>
    <link href="/omcat.github.io/2025/02/21/DCU%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <url>/omcat.github.io/2025/02/21/DCU%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>按照CSDN的第一个教程操作之后(<a href="https://blog.csdn.net/weixin_43800577/article/details/127918593)%EF%BC%8Csource">https://blog.csdn.net/weixin_43800577/article/details/127918593)，source</a> torch.env.sh (就是：“在本地创建一个pytorch_env.sh的文件，添加环境变量！”这一步)，然后运行代码python xxx.py</p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DCU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GRRM_build安装指南</title>
    <link href="/omcat.github.io/2025/02/21/GRRM_build%E5%AE%89%E8%A3%85%E8%AF%B7%E7%9C%8B%E8%BF%99%E4%B8%AA/"/>
    <url>/omcat.github.io/2025/02/21/GRRM_build%E5%AE%89%E8%A3%85%E8%AF%B7%E7%9C%8B%E8%BF%99%E4%B8%AA/</url>
    
    <content type="html"><![CDATA[<p>按照PleaseReadFirst.pdf中的内容一步一步安装，注意点是必须首先获取linux系统的管理员权限：</p><h1 id="su"><a href="#su" class="headerlink" title="su"></a>su</h1><h1 id="sudo-root-centos系统"><a href="#sudo-root-centos系统" class="headerlink" title="sudo root    &#x2F;&#x2F;centos系统"></a>sudo root    &#x2F;&#x2F;centos系统</h1><p>然后输入密码就可以</p><p>第一步安装用于验证软件许可证的动态库文件（.so）,安装位置为文件中推荐的&#x2F;usr&#x2F;lib64，然后需要验证网络端口是否为”eth0”，只要出现这个关键词就算完成这一步。</p><p>第二步是把程序的两个主文件安装到对应的位置，即我们通过教程中命令行创建的安装位置&#x2F;usr&#x2F;local&#x2F;GRRM14Beta。这个文件夹的访问权限要设置为最高的，教程里面写的不行，按照下面的命令行来设置权限为777，且对所有用户均可访问：</p><h1 id="sudo-chmod-R-777-usr-local-GRRM14Beta"><a href="#sudo-chmod-R-777-usr-local-GRRM14Beta" class="headerlink" title="sudo chmod -R 777 &#x2F;usr&#x2F;local&#x2F;GRRM14Beta"></a>sudo chmod -R 777 &#x2F;usr&#x2F;local&#x2F;GRRM14Beta</h1><p>然后，echo $SHELL 这个命令是查看当前的linux系统的批量处理命令类型是什么，可能是csh或者是bash，如果是bash就用最后一种命令的方式来添加GRRM的环境变量。即：</p><h1 id="vim-HOME-bash-profile-这一行是用vim打开-bash-profile进行编辑"><a href="#vim-HOME-bash-profile-这一行是用vim打开-bash-profile进行编辑" class="headerlink" title="vim $HOME&#x2F;.bash_profile    &#x2F;&#x2F;这一行是用vim打开.bash_profile进行编辑"></a>vim $HOME&#x2F;.bash_profile    &#x2F;&#x2F;这一行是用vim打开.bash_profile进行编辑</h1><h1 id="export-GRRMrootBeta-usr-local-GRRM14Beta"><a href="#export-GRRMrootBeta-usr-local-GRRM14Beta" class="headerlink" title="export GRRMrootBeta&#x3D;&#x2F;usr&#x2F;local&#x2F;GRRM14Beta"></a>export GRRMrootBeta&#x3D;&#x2F;usr&#x2F;local&#x2F;GRRM14Beta</h1><h1 id="export-subgau-g09"><a href="#export-subgau-g09" class="headerlink" title="export subgau&#x3D;g09"></a>export subgau&#x3D;g09</h1><h1 id="export-subchk-formchk"><a href="#export-subchk-formchk" class="headerlink" title="export subchk&#x3D;formchk"></a>export subchk&#x3D;formchk</h1><h1 id="export-subgrr-GRRM-out"><a href="#export-subgrr-GRRM-out" class="headerlink" title="export subgrr&#x3D;GRRM.out"></a>export subgrr&#x3D;GRRM.out</h1><h1 id="PATH-PATH-GRRMrootBeta"><a href="#PATH-PATH-GRRMrootBeta" class="headerlink" title="PATH&#x3D;$PATH:$GRRMrootBeta"></a>PATH&#x3D;$PATH:$GRRMrootBeta</h1><h1 id="export-PATH"><a href="#export-PATH" class="headerlink" title="export PATH"></a>export PATH</h1><p>（注意：编辑过程中，进去之后先按i键或者insert进入编辑模式，然后把上述内容粘贴进去，然后按Esc退出编辑、保存同时进入命令模式，最后按shift+z+z退出vim）</p><p>第三步，在命令行输入GRRMpBeta看看输出结果是否是安装教程中那样，如果是就安装成功了。</p><p>可能出现的错误和解决办法：</p><ol><li>第一步验证网络端口的地方，如果是自己新安装的linux系统可能会没有网络工具，这个时候需要自行先安装，对于ubuntu系统，命令如下：</li></ol><h1 id="sudo-apt-install-net-tools-安装net-tools"><a href="#sudo-apt-install-net-tools-安装net-tools" class="headerlink" title="sudo apt install net-tools    &#x2F;&#x2F;安装net-tools"></a>sudo apt install net-tools    &#x2F;&#x2F;安装net-tools</h1><h1 id="sbin-ifconfig-a-装完之后看看有没有网络接口"><a href="#sbin-ifconfig-a-装完之后看看有没有网络接口" class="headerlink" title="&#x2F;sbin&#x2F;ifconfig -a    &#x2F;&#x2F;装完之后看看有没有网络接口"></a>&#x2F;sbin&#x2F;ifconfig -a    &#x2F;&#x2F;装完之后看看有没有网络接口</h1><p>（另外，对于centos这里的安装命令不太一样，要用yum好像）</p><ol start="2"><li><p>第二步按照教程安装给&#x2F;usr&#x2F;local&#x2F;GRRM14Beta这个文件夹的访问权限不够的话，最后软件会用不了，建议按照本文所给的命令设置权限。</p></li><li><p>可能会提示第一步安装的动态库.so文件无法访问，这里也是由于没有设置好其访问权限，通过以下方式解决：<br>动态库访问权限设置</p></li></ol><h1 id="ldconfig"><a href="#ldconfig" class="headerlink" title="ldconfig"></a>ldconfig</h1><h1 id="vim-etc-ld-so-conf-在新的一行中加入库文件所在目录"><a href="#vim-etc-ld-so-conf-在新的一行中加入库文件所在目录" class="headerlink" title="vim &#x2F;etc&#x2F;ld.so.conf      &#x2F;&#x2F;在新的一行中加入库文件所在目录"></a>vim &#x2F;etc&#x2F;ld.so.conf      &#x2F;&#x2F;在新的一行中加入库文件所在目录</h1><p>&#x2F;usr&#x2F;lib64    &#x2F;&#x2F;需要用编辑器加入这一行</p><h1 id="ldconfig-更新-etc-ld-so-cache文件"><a href="#ldconfig-更新-etc-ld-so-cache文件" class="headerlink" title="ldconfig                 &#x2F;&#x2F;更新&#x2F;etc&#x2F;ld.so.cache文件"></a>ldconfig                 &#x2F;&#x2F;更新&#x2F;etc&#x2F;ld.so.cache文件</h1><ol start="4"><li><p>修改bash文件的注意事项<br>修改和更新bash文件用以下命令<br>vim ~&#x2F;.bashrc<br>source ~&#x2F;.bashrc<br>对于g09，xtb和GRRM软件都要在root下运行，所以修改bash文件也要切换到root下，不然修改的是当前用户的bash文件不起作用</p></li><li><p>Syntax error: Bad fd number报错的解决办法(<a href="https://blog.csdn.net/qq_44664843/article/details/120509888">https://blog.csdn.net/qq_44664843/article/details/120509888</a>)<br>这个错误是执行sh脚本时报的错误，而且是打开文件的时候的发生的错误。<br>解决方案：<br>经过查阅资料得知，有可能是sh链接到了dash，而非bash，因此只需要检查链接情况即可。<br>执行命令<br>ls -l &#x2F;bin&#x2F;sh<br>结果：&#x2F;bin&#x2F;sh -&gt; dash<br>如果得到这样的输出，就执行以下命令：<br>sudo mv &#x2F;bin&#x2F;sh &#x2F;bin&#x2F;sh.orig<br>sudo ln -s &#x2F;bin&#x2F;bash &#x2F;bin&#x2F;sh<br>再次检查：<br>得到输出为&#x2F;bin&#x2F;sh  -&gt; &#x2F;bin&#x2F;bash</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>量子化学软件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>安装</tag>
      
      <tag>GRRM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GPAW安装教程</title>
    <link href="/omcat.github.io/2025/02/21/GPAW%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
    <url>/omcat.github.io/2025/02/21/GPAW%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>安装链接：<br><a href="https://wiki.fysik.dtu.dk/gpaw/platforms/Linux/ubuntu.html">https://wiki.fysik.dtu.dk/gpaw/platforms/Linux/ubuntu.html</a> 按这个来更好，比installation的教程更不容易报错<br>其他安装方法：<br><a href="https://zhuanlan.zhihu.com/p/370192750">https://zhuanlan.zhihu.com/p/370192750</a><br><a href="https://zhuanlan.zhihu.com/p/579031419#:~:text=conda%20create%20--name%20gpaw-env%20%E7%AC%AC%E4%BA%94%E6%AD%A5%EF%BC%9A%E8%BF%9B%E5%85%A5%E6%BF%80%E6%B4%BB%E5%AE%83%EF%BC%9A%20conda%20activate%20gpaw-env,-c%20conda-forge%20gpaw%20%E8%BF%99%E4%B8%AA%E6%96%B9%E6%B3%95%E7%9C%9F%E7%9A%84%E5%BE%88%E7%AE%80%E5%8D%95%EF%BC%8C%E4%BD%A0%E5%8F%AA%E9%9C%80%E8%A6%81%E6%8A%8A%E6%88%91%E4%B8%8A%E9%9D%A2%E7%9A%84%E4%BB%A3%E7%A0%81%E7%9B%B4%E6%8E%A5%E5%A4%8D%E5%88%B6%E5%88%B0%E4%BD%A0%E7%9A%84Linux%E4%B8%8B%E5%B0%B1%E5%8F%AF%E4%BB%A5%EF%BC%8C%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4%E8%BF%98%E6%9C%89%E4%BA%BA%E4%B8%8D%E4%BC%9A%E5%90%97%E3%80%82%20%E8%80%8C%E4%B8%94%E5%AE%89%E8%A3%85%E5%AE%8C%E6%88%90%E5%90%8E%E7%9A%84GPAW%E5%BA%93%E7%9C%9F%E7%9A%84%E5%BE%88%E5%85%A8%EF%BC%8C%E4%BD%BF%E7%94%A8%20gpaw%20info%20%E6%9F%A5%E7%9C%8B%EF%BC%9A">https://zhuanlan.zhihu.com/p/579031419#:~:text=conda%20create%20--name%20gpaw-env%20%E7%AC%AC%E4%BA%94%E6%AD%A5%EF%BC%9A%E8%BF%9B%E5%85%A5%E6%BF%80%E6%B4%BB%E5%AE%83%EF%BC%9A%20conda%20activate%20gpaw-env,-c%20conda-forge%20gpaw%20%E8%BF%99%E4%B8%AA%E6%96%B9%E6%B3%95%E7%9C%9F%E7%9A%84%E5%BE%88%E7%AE%80%E5%8D%95%EF%BC%8C%E4%BD%A0%E5%8F%AA%E9%9C%80%E8%A6%81%E6%8A%8A%E6%88%91%E4%B8%8A%E9%9D%A2%E7%9A%84%E4%BB%A3%E7%A0%81%E7%9B%B4%E6%8E%A5%E5%A4%8D%E5%88%B6%E5%88%B0%E4%BD%A0%E7%9A%84Linux%E4%B8%8B%E5%B0%B1%E5%8F%AF%E4%BB%A5%EF%BC%8C%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4%E8%BF%98%E6%9C%89%E4%BA%BA%E4%B8%8D%E4%BC%9A%E5%90%97%E3%80%82%20%E8%80%8C%E4%B8%94%E5%AE%89%E8%A3%85%E5%AE%8C%E6%88%90%E5%90%8E%E7%9A%84GPAW%E5%BA%93%E7%9C%9F%E7%9A%84%E5%BE%88%E5%85%A8%EF%BC%8C%E4%BD%BF%E7%94%A8%20gpaw%20info%20%E6%9F%A5%E7%9C%8B%EF%BC%9A</a></p><p>解决libstdc++.so.6: version &#96;GLIBCXX_3.4.30’报错：<br><a href="https://zhuanlan.zhihu.com/p/637165718">https://zhuanlan.zhihu.com/p/637165718</a></p><p>安装泛函数据:<br>gpaw install-data <dir><br>export GPAW_SETUP_PATH&#x3D;~&#x2F;PAW_datasets&#x2F;gpaw-setups-24.1.0</p><p>最后测试：<br>gpaw info<br>gpaw test<br>gpaw -P 4 test</p>]]></content>
    
    
    <categories>
      
      <category>量子化学软件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>安装</tag>
      
      <tag>GPAW</tag>
      
      <tag>DFT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SISSO安装</title>
    <link href="/omcat.github.io/2025/02/21/SISSO%E5%AE%89%E8%A3%85/"/>
    <url>/omcat.github.io/2025/02/21/SISSO%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Python/机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>安装</tag>
      
      <tag>机器学习</tag>
      
      <tag>SISSO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gaussian指令技巧</title>
    <link href="/omcat.github.io/2025/02/21/Gaussian%E6%8C%87%E4%BB%A4%E6%8A%80%E5%B7%A7/"/>
    <url>/omcat.github.io/2025/02/21/Gaussian%E6%8C%87%E4%BB%A4%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<p>–Link1–<br>%nprocshared&#x3D;8<br>%chk&#x3D;ts000000_1.chk<br>%NoSave<br>这里的%NoSave可以在算完之后，不保存chk文件</p>]]></content>
    
    
    <categories>
      
      <category>量子化学软件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算化学</tag>
      
      <tag>Gaussian</tag>
      
      <tag>技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gaussian09安装指南（Linux）</title>
    <link href="/omcat.github.io/2025/02/21/Gaussian09%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97%E4%B8%80%EF%BC%88linux%EF%BC%89/"/>
    <url>/omcat.github.io/2025/02/21/Gaussian09%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97%E4%B8%80%EF%BC%88linux%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>gaussian不需要root权限，只需要普通用户即可。假设普通账户名为kdywwldut</p><ol><li>把g09拷贝到一个目录下（需建立一个新文件夹，如名称为software），假设<br>为 &#x2F;home&#x2F;kdywwldut&#x2F;software</li><li>然后使用命令 tar -zxvf E64_930X.TGZ 解压安装文件<br>（此处E64_930X.TGZ即为Gaussian软件安装文件，光盘里可能会<br>有其它文件，但只有这个是安装文件）<br>3.然后会出现一个g09 的目录，此时g09的目录应该为&#x2F;home&#x2F;kdywwldut&#x2F;software&#x2F;g09</li><li>然后编辑&#x2F;home&#x2F;kdywwldut&#x2F;software&#x2F;.bashrc文件，加入以下5行. 命令为vim ~&#x2F;.bashrc</li></ol><p>export g09root&#x3D;&#x2F;home&#x2F;software  &#x2F;&#x2F;安装目录的上一级目录<br>export GAUSS_EXEDIR&#x3D;$g09root&#x2F;g09<br>export GAUSS_SCRDIR&#x3D;$g09root&#x2F;g09&#x2F;scratch<br>export PATH&#x3D;$PATH:$g09root&#x2F;g09</p><ol start="5"><li>编辑好之后，保存退出（shift + zz）. 在&#x2F;home 目录下使用命令 source .bashrc</li><li>然后使用which g09 如果输出结果为&#x2F;home&#x2F;g09&#x2F;g09 则表示安装成功。</li><li>设置文件夹的访问权限为750 sudo chmod -R 750 &#x2F;work&#x2F;home&#x2F;casdao&#x2F;kdywwldut&#x2F;kdywwldut&#x2F;software&#x2F;g09<br>777权限太低了会报错</li></ol><p>（注意，g09安装目录的权限必须按照这样来设置 # chmod 750 -R &#x2F;home&#x2F;g09&#x2F;g09，权限只能给750）</p><p>在多路CPU上安装高斯的环境变量：</p><h1 id="gaussian-16"><a href="#gaussian-16" class="headerlink" title="gaussian 16"></a>gaussian 16</h1><p>export OMP_THREAD_LIMT&#x3D;256<br>export PGI_FASTMATH_CPU&#x3D;sandybridge<br>export g16root&#x3D;&#x2F;home&#x2F;user&#x2F;Documents&#x2F;softwares<br>export GAUSS_SCRDIR&#x3D;&#x2F;home&#x2F;user&#x2F;Documents&#x2F;softwares&#x2F;g16&#x2F;scratch<br>source $g16root&#x2F;g16&#x2F;bsd&#x2F;g16.profile</p>]]></content>
    
    
    <categories>
      
      <category>量子化学软件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>安装</tag>
      
      <tag>Gaussian</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>英语口语技巧</title>
    <link href="/omcat.github.io/2025/02/21/Spoken_English_tips/"/>
    <url>/omcat.github.io/2025/02/21/Spoken_English_tips/</url>
    
    <content type="html"><![CDATA[<ol><li>英文单词的发音一定要准确，对照音标纠正大量英文读音；</li><li>英语单词的连读，重音，长句子的停顿等等，需要具体而言具体练习，多读多练；</li><li>日常用语，地道表达需要具体学习。</li></ol>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>英语</tag>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>fairchem+ewaldmpn安装步骤</title>
    <link href="/omcat.github.io/2025/02/21/fairchem+ewaldmpn%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4/"/>
    <url>/omcat.github.io/2025/02/21/fairchem+ewaldmpn%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4/</url>
    
    <content type="html"><![CDATA[<ol><li><p>进入网页：<a href="https://fair-chem.github.io/core/install.html#Conda">https://fair-chem.github.io/core/install.html#Conda</a></p></li><li><p>执行以下两句，使用conda安装基础环境<br>wget <a href="https://raw.githubusercontent.com/FAIR-Chem/fairchem/main/packages/env.gpu.yml">https://raw.githubusercontent.com/FAIR-Chem/fairchem/main/packages/env.gpu.yml</a><br>conda env create -f env.gpu.yml</p></li><li><p>conda安装的torch很可能是cpu版本的，因此需要重新安装合适的GPU版本torch，执行：<br>pip install torch&#x3D;&#x3D;2.2.2+cu118 torchvision -f <a href="https://download.pytorch.org/whl/torch_stable.html">https://download.pytorch.org/whl/torch_stable.html</a></p></li><li><p>执行Iron_NNPs-master中的setup.py安装fair-chem中的一些包，就不用安装fair-chem.core这个库了，到Iron_NNPs-master路径下执行：<br>python setup.py install</p></li><li><p>安装完毕，可以运行训练代码</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Python/机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>安装</tag>
      
      <tag>机器学习</tag>
      
      <tag>fairchem</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gaussian09+xTB+GRRM14配置</title>
    <link href="/omcat.github.io/2025/02/21/g09+xtb+GRRM14/"/>
    <url>/omcat.github.io/2025/02/21/g09+xtb+GRRM14/</url>
    
    <content type="html"><![CDATA[<h2 id="三个软件命令行开头：g09xtbGRRMpBeta"><a href="#三个软件命令行开头：g09xtbGRRMpBeta" class="headerlink" title="三个软件命令行开头：g09xtbGRRMpBeta"></a>三个软件命令行开头：<br>g09<br>xtb<br>GRRMpBeta</h2><h2 id="GRRM运行命令：source-bashrccd-home-tangkun-work-grrmGRRMpBeta-TJ08-p2-h1！！！GRRMpBeta-TJ01-p1-h1-有些任务是只能单线程的，比如TJ01和TJ04，不然会报错No-parallel-algorithm-for-the-minimum-optimization"><a href="#GRRM运行命令：source-bashrccd-home-tangkun-work-grrmGRRMpBeta-TJ08-p2-h1！！！GRRMpBeta-TJ01-p1-h1-有些任务是只能单线程的，比如TJ01和TJ04，不然会报错No-parallel-algorithm-for-the-minimum-optimization" class="headerlink" title="GRRM运行命令：source .bashrccd &#x2F;home&#x2F;tangkun&#x2F;work&#x2F;grrmGRRMpBeta TJ08 -p2 -h1！！！GRRMpBeta TJ01 -p1 -h1  &#x2F;&#x2F;有些任务是只能单线程的，比如TJ01和TJ04，不然会报错No parallel algorithm for the minimum optimization!"></a>GRRM运行命令：<br>source .bashrc<br>cd &#x2F;home&#x2F;tangkun&#x2F;work&#x2F;grrm<br>GRRMpBeta TJ08 -p2 -h1<br>！！！GRRMpBeta TJ01 -p1 -h1  &#x2F;&#x2F;有些任务是只能单线程的，比如TJ01和TJ04，不然会报错No parallel algorithm for the minimum optimization!</h2><ol><li>GRRM也可以和g16联用，更改环境变量即可</li><li>也可以用GRRM-&gt;Gaussian-&gt;xtb来计算，效率很高，但别忘了要把xtb.sh放到工作目录中，这样GRRM调用高斯之后，高斯才能从外部调用xtb来计算能量和力并反馈给GRRM算法采样搜索。</li><li>gau + grrm + xtb的工作文件夹必须设置成777权限才能正常运行输出结果</li></ol><hr><h2 id="第一个问题：-bash-ulimit-stack-size-cannot-modify-limit-Invalid-argument这一行报错是因为设置了xtb后，export-OMP-STACKSIZE-1000m这个环境变量，这两者是冲突的，没办法解决。所以想要三者联动，只能在root下同时运行，每一次都要输入我的账号密码：41259ulimit-s-unlimited-意思是无限内存，加上会每次都弹出警告（非root模式下），所以最后把xtb环境变量里面的下面这两句都删了就好了：export-OMP-STACKSIZE-1000mulimit-s-unlimited"><a href="#第一个问题：-bash-ulimit-stack-size-cannot-modify-limit-Invalid-argument这一行报错是因为设置了xtb后，export-OMP-STACKSIZE-1000m这个环境变量，这两者是冲突的，没办法解决。所以想要三者联动，只能在root下同时运行，每一次都要输入我的账号密码：41259ulimit-s-unlimited-意思是无限内存，加上会每次都弹出警告（非root模式下），所以最后把xtb环境变量里面的下面这两句都删了就好了：export-OMP-STACKSIZE-1000mulimit-s-unlimited" class="headerlink" title="第一个问题：-bash: ulimit: stack size: cannot modify limit: Invalid argument这一行报错是因为设置了xtb后，export OMP_STACKSIZE&#x3D;1000m这个环境变量，这两者是冲突的，没办法解决。所以想要三者联动，只能在root下同时运行，每一次都要输入我的账号密码：41259ulimit -s unlimited 意思是无限内存，加上会每次都弹出警告（非root模式下），所以最后把xtb环境变量里面的下面这两句都删了就好了：export OMP_STACKSIZE&#x3D;1000mulimit -s unlimited"></a>第一个问题：<br>-bash: ulimit: stack size: cannot modify limit: Invalid argument<br>这一行报错是因为设置了xtb后，export OMP_STACKSIZE&#x3D;1000m这个环境变量，这两者是冲突的，没办法解决。<br>所以想要三者联动，只能在root下同时运行，每一次都要输入我的账号密码：41259<br>ulimit -s unlimited 意思是无限内存，加上会每次都弹出警告（非root模式下），所以最后把xtb环境变量里面的下面这两句都删了就好了：<br>export OMP_STACKSIZE&#x3D;1000m<br>ulimit -s unlimited</h2><h2 id="第二个问题：如果出现：安装后显示MAC地址，安装成功了；但是，运行测试案例显示：段错误，核心已转储（free-invalid-next-size-fast-Aborted-core-dumped-）那么就是因为这个——-“Linux执行sh脚本报错-Syntax-error-Bad-fd-number”url-https-blog-csdn-net-qq-44664843-article-details-120509888可能是sh链接到了dash，而非bash，因此只需要检查链接情况即可。ls-l-bin-sh如果返回了dash的结果，按如下操作：sudo-mv-bin-sh-bin-sh-origsudo-ln-s-bin-bash-bin-sh最后再用ls-l-bin-sh检查结果是链接到–-bin-bash就行了"><a href="#第二个问题：如果出现：安装后显示MAC地址，安装成功了；但是，运行测试案例显示：段错误，核心已转储（free-invalid-next-size-fast-Aborted-core-dumped-）那么就是因为这个——-“Linux执行sh脚本报错-Syntax-error-Bad-fd-number”url-https-blog-csdn-net-qq-44664843-article-details-120509888可能是sh链接到了dash，而非bash，因此只需要检查链接情况即可。ls-l-bin-sh如果返回了dash的结果，按如下操作：sudo-mv-bin-sh-bin-sh-origsudo-ln-s-bin-bash-bin-sh最后再用ls-l-bin-sh检查结果是链接到–-bin-bash就行了" class="headerlink" title="第二个问题：如果出现：安装后显示MAC地址，安装成功了；但是，运行测试案例显示：段错误，核心已转储（free(): invalid next size (fast) Aborted (core dumped)）那么就是因为这个——&gt;“Linux执行sh脚本报错: Syntax error: Bad fd number”url https://blog.csdn.net/qq_44664843/article/details/120509888可能是sh链接到了dash，而非bash，因此只需要检查链接情况即可。ls -l &#x2F;bin&#x2F;sh如果返回了dash的结果，按如下操作：sudo mv &#x2F;bin&#x2F;sh &#x2F;bin&#x2F;sh.origsudo ln -s &#x2F;bin&#x2F;bash &#x2F;bin&#x2F;sh最后再用ls -l &#x2F;bin&#x2F;sh检查结果是链接到–&gt;&#x2F;bin&#x2F;bash就行了"></a>第二个问题：<br>如果出现：<br>安装后显示MAC地址，安装成功了；但是，运行测试案例显示：段错误，核心已转储（free(): invalid next size (fast) Aborted (core dumped)）<br>那么就是因为这个——&gt;“Linux执行sh脚本报错: Syntax error: Bad fd number”url <a href="https://blog.csdn.net/qq_44664843/article/details/120509888">https://blog.csdn.net/qq_44664843/article/details/120509888</a><br>可能是sh链接到了dash，而非bash，因此只需要检查链接情况即可。<br>ls -l &#x2F;bin&#x2F;sh<br>如果返回了dash的结果，按如下操作：<br>sudo mv &#x2F;bin&#x2F;sh &#x2F;bin&#x2F;sh.orig<br>sudo ln -s &#x2F;bin&#x2F;bash &#x2F;bin&#x2F;sh<br>最后再用ls -l &#x2F;bin&#x2F;sh检查<br>结果是链接到–&gt;&#x2F;bin&#x2F;bash就行了</h2><p>第三个问题：<br>grrm + gau + xtb联用是可行的，但是要设置好文件夹的读写权限为777，然后xtb貌似不支持多线程，在GRRM运行时只能单线程设置-p1</p>]]></content>
    
    
    <categories>
      
      <category>量子化学软件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GRRM</tag>
      
      <tag>Gaussian</tag>
      
      <tag>xTB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git clone网络错误解决</title>
    <link href="/omcat.github.io/2025/02/21/git%20clone%E7%BD%91%E7%BB%9C%E9%94%99%E8%AF%AF/"/>
    <url>/omcat.github.io/2025/02/21/git%20clone%E7%BD%91%E7%BB%9C%E9%94%99%E8%AF%AF/</url>
    
    <content type="html"><![CDATA[<p>输入这两个就行：<br>git config –global http.proxy <a href="http://127.0.0.1:7890/">http://127.0.0.1:7890</a><br>git config –global https.proxy <a href="http://127.0.0.1:7890/">http://127.0.0.1:7890</a><br>如果要取消代理：<br>git config –global –unset http.proxy<br>git config –global –unset https.proxy </p>]]></content>
    
    
    <categories>
      
      <category>Linux/WSL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAX安装</title>
    <link href="/omcat.github.io/2025/02/21/jax%E5%AE%89%E8%A3%85/"/>
    <url>/omcat.github.io/2025/02/21/jax%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<p>jax和jaxlib要和torch一样用cuda11.8的版本，兼容性最好</p><p>pip install –upgrade jax&#x3D;&#x3D;0.4.20 jaxlib&#x3D;&#x3D;0.4.20+cuda11.cudnn86 -f <a href="https://storage.googleapis.com/jax-releases/jax_cuda_releases.html">https://storage.googleapis.com/jax-releases/jax_cuda_releases.html</a></p>]]></content>
    
    
    <categories>
      
      <category>Python/机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>安装</tag>
      
      <tag>JAX</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>libxc安装教程</title>
    <link href="/omcat.github.io/2025/02/21/libxc%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
    <url>/omcat.github.io/2025/02/21/libxc%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>前提安装：sudo apt install automake libtool m4 autoconf</p><ol><li><p>去gitlab下载源代码 <a href="https://gitlab.com/libxc/libxc/-/archive/6.2.2/libxc-6.2.2.tar.gz">https://gitlab.com/libxc/libxc/-/archive/6.2.2/libxc-6.2.2.tar.gz</a></p></li><li><p>按照以下步骤在linux命令行中执行脚本：<br>tar -xf libxc-6.2.2.tar.gz<br>cd libxc-6.2.2<br>autoreconf -i<br>.&#x2F;configure CC&#x3D;c99 –enable-shared –disable-fortran –prefix&#x3D;$HOME&#x2F;libxc-6.2.2<br>make<br>make check<br>make install</p></li><li><p>添加环境变量</p></li></ol><h1 id="add-these-to-your-bashrc"><a href="#add-these-to-your-bashrc" class="headerlink" title="add these to your .bashrc:"></a>add these to your .bashrc:</h1><p>XC&#x3D;~&#x2F;libxc-6.2.2<br>export C_INCLUDE_PATH&#x3D;$XC&#x2F;include<br>export LIBRARY_PATH&#x3D;$XC&#x2F;lib<br>export LD_LIBRARY_PATH&#x3D;$XC&#x2F;lib</p>]]></content>
    
    
    <categories>
      
      <category>量子化学软件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>安装</tag>
      
      <tag>DFT</tag>
      
      <tag>libxc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pyGSM的安装</title>
    <link href="/omcat.github.io/2025/02/21/pyGSM%E7%9A%84%E5%AE%89%E8%A3%85/"/>
    <url>/omcat.github.io/2025/02/21/pyGSM%E7%9A%84%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<p>pyGSM库地址：<a href="https://github.com/ZimmermanGroup/pyGSM">https://github.com/ZimmermanGroup/pyGSM</a></p><p>建议使用linux环境运行，安装步骤如下：</p><ol><li><p>安装anaconda linux版本，网上有相关教程，下载对应版本的.sh文件后直接bash运行然后选定安装目录即可，可以选择安装在&#x2F;opt&#x2F;anaconda3文件夹下，方便后续打开查看（无需root权限）。<br>最后将conda添加进环境变量，输入vim ~&#x2F;.bashrc（在bashrc中添加 export PATH&#x3D;&#x2F;opt&#x2F;anaconda3&#x2F;bin:$PATH ），退出保存（source ~&#x2F;.bashrc）；</p></li><li><p>新建pygsm虚拟环境（conda create -n pygsm python&#x3D;3.9），然后激活（conda activate pygsm）。然后安装pygsm库（pip3 install git+<a href="https://github.com/ZimmermanGroup/pyGSM.git%EF%BC%89%E3%80%82">https://github.com/ZimmermanGroup/pyGSM.git）。</a><br>pygsm可以结合xtb一起使用，因此可以在conda pygsm虚拟环境中安装上xtb（conda install -c conda-forge xtb）；</p></li><li><p>新建工作目录，即可在目录中使用gsm关键词搜索TS。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Python/机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>安装</tag>
      
      <tag>Python</tag>
      
      <tag>pyGSM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Slurm脚本模板</title>
    <link href="/omcat.github.io/2025/02/21/slurm%E8%84%9A%E6%9C%AC%E6%A8%A1%E6%9D%BF/"/>
    <url>/omcat.github.io/2025/02/21/slurm%E8%84%9A%E6%9C%AC%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<p>#!&#x2F;bin&#x2F;bash</p><p>#SBATCH -n 1 # 指定核心数量<br>#SBATCH -N 1 # 指定node的数量<br>#SBATCH -t 0-5:00 # 运行总时间，天数-小时数-分钟， D-HH:MM<br>#SBATCH -p debug # 提交到哪一个分区<br>#SBATCH –mem&#x3D;2000 # 所有核心可以使用的内存池大小，MB为单位<br>#SBATCH -o myjob.o # 把输出结果STDOUT保存在哪一个文件<br>#SBATCH -e myjob.e # 把报错结果STDERR保存在哪一个文件<br>#SBATCH –mail-type&#x3D;ALL # 发送哪一种email通知：BEGIN,END,FAIL,ALL<br>#SBATCH --mail-user&#x3D;<a href="mailto:&#110;&#101;&#116;&#105;&#x64;&#64;&#x6e;&#121;&#x75;&#x2e;&#101;&#100;&#117;">netid@nyu.edu</a> # 把通知发送到哪一个邮箱<br>#SBATCH –constraint&#x3D;2630v3  # the Features of the nodes, using command “ showcluster “ could find them.<br>#SBATCH –gres&#x3D;gpu:n # 需要使用多少GPU，n是需要的数量</p><p>runYourCommandHere</p>]]></content>
    
    
    <categories>
      
      <category>Linux/WSL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Slurm</tag>
      
      <tag>超算</tag>
      
      <tag>作业调度</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VB批量标记修订</title>
    <link href="/omcat.github.io/2025/02/21/VB%E6%89%B9%E9%87%8F%E6%A0%87%E8%AE%B0%E4%BF%AE%E8%AE%A2/"/>
    <url>/omcat.github.io/2025/02/21/VB%E6%89%B9%E9%87%8F%E6%A0%87%E8%AE%B0%E4%BF%AE%E8%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>打开你的 Word 文档。</p><p>按下 ALT+F11 快捷键，打开 Visual Basic 编辑器。</p><p>在“项目”窗口中，选择你的 Word 文档。</p><p>点击“插入”菜单，然后选择“模块”。</p><p>在新建的模块中，复制并粘贴以下 VBA 代码：</p><p>Sub HighlightRevisions()<br>    Dim r As Revision</p><pre><code class="hljs">For Each r In ActiveDocument.Revisions    r.Range.HighlightColorIndex = wdYellowNext r</code></pre><p>End Sub</p><p>如果只标记插入的部分文字应该怎么写VB代码？<br>如果你只想标记修订中的插入部分，可以在 VBA 代码中添加一个条件语句，仅仅对插入的修订进行标记。以下是一个示例代码：<br>Sub HighlightInsertedText()<br>    Dim r As Revision<br>    For Each r In ActiveDocument.Revisions<br>        If r.Type &#x3D; wdRevisionInsert Then<br>            r.Range.HighlightColorIndex &#x3D; wdYellow<br>        End If<br>    Next r<br>End Sub<br>在这个示例代码中，我们首先定义了一个名为 “HighlightInsertedText” 的子程序，它会遍历所有的修订。在每次遍历过程中，代码会检查当前修订的类型是否为 “wdRevisionInsert”，如果是，则将其突出显示为黄色底色。如果不是插入的修订，则跳过该修订不做任何处理。</p><p>当你运行这个 VBA 代码时，它将仅标记所有插入的修订，而不会标记任何删除或移动的修订。如果需要标记其他类型的修订，可以更改代码中的条件语句以匹配所需的修订类型。</p><p>整合了标记插入、删除和移动修订的 VBA 代码：<br>Sub HighlightRevisions()<br>    Dim r As Revision<br>    For Each r In ActiveDocument.Revisions<br>        If r.Type &#x3D; wdRevisionInsert Then<br>            r.Range.HighlightColorIndex &#x3D; wdYellow<br>        ElseIf r.Type &#x3D; wdRevisionDelete Then<br>            r.Range.HighlightColorIndex &#x3D; wdYellow<br>        ElseIf r.Type &#x3D; wdRevisionMovedFrom Then<br>            r.Range.HighlightColorIndex &#x3D; wdYellow<br>        ElseIf r.Type &#x3D; wdRevisionMovedTo Then<br>            r.Range.HighlightColorIndex &#x3D; wdYellow<br>        End If<br>    Next r<br>End Sub</p><p>去掉其中标记删除的部分<br>Sub HighlightInsertedAndMovedRevisions()<br>    Dim r As Revision<br>    For Each r In ActiveDocument.Revisions<br>        If r.Type &#x3D; wdRevisionInsert Then<br>            r.Range.HighlightColorIndex &#x3D; wdYellow<br>        ElseIf r.Type &#x3D; wdRevisionMovedFrom Then<br>            r.Range.HighlightColorIndex &#x3D; wdYellow<br>        ElseIf r.Type &#x3D; wdRevisionMovedTo Then<br>            r.Range.HighlightColorIndex &#x3D; wdYellow<br>        End If<br>    Next r<br>End Sub<br>这个代码将标记插入和移动修订，而不是删除修订。如果你只想标记插入修订和移动的修订，则可以将代码修改为：<br>Sub HighlightInsertedAndMovedRevisions()<br>    Dim r As Revision<br>    For Each r In ActiveDocument.Revisions<br>        If r.Type &#x3D; wdRevisionInsert Then<br>            r.Range.HighlightColorIndex &#x3D; wdYellow<br>        ElseIf r.Type &#x3D; wdRevisionMovedFrom Or r.Type &#x3D; wdRevisionMovedTo Then<br>            r.Range.HighlightColorIndex &#x3D; wdYellow<br>        End If<br>    Next r<br>End Sub<br>这个代码将仅标记插入修订和移动的修订，并将它们突出显示为黄色底色。</p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VB</tag>
      
      <tag>Office</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux常用命令</title>
    <link href="/omcat.github.io/2025/02/21/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/omcat.github.io/2025/02/21/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>#复制固定后缀名的文件<br>mkdir -p 500log&#x2F;500r_log #创建新的文件夹<br>mkdir -p 500log&#x2F;500ts_log<br>cp 500r&#x2F;<em>.log 500log&#x2F;500r_log<br>cp 500ts-1&#x2F;</em>.log 500log&#x2F;500ts_log #复制.log后缀文件命令<br>cp 500ts-2&#x2F;<em>.log 500log&#x2F;500ts_log<br>cp 500ts-3&#x2F;</em>.log 500log&#x2F;500ts_log</p><p>#压缩文件命令<br>tar -zcvf 500log&#x2F;500r_log.tar.gz 500log&#x2F;500r_log &gt; &#x2F;dev&#x2F;null 2&gt;&amp;1 #将500log&#x2F;500r_log文件夹压缩<br>tar -zcvf 500log&#x2F;500ts_log.tar.gz 500log&#x2F;500ts_log &gt; &#x2F;dev&#x2F;null 2&gt;&amp;1</p><p>#修改和更新bash文件<br>vim ~&#x2F;.bashrc<br>source ~&#x2F;.bashrc</p><p>#切换到root用户<br>su<br>或者su - root<br>二者有区别，后者是把原来的环境也加载到root用户条件下，不会出现命令not found的情况</p><p>#linux的环境变量配置地址<br>有两种，一种是&#x2F;etc&#x2F;目录下的bash.bashrc，profile，environment三个文件，这里面的是全局环境变量，在所有的用户下均会生效<br>一种是&#x2F;home&#x2F;tangkun&#x2F;个人用户文件夹中的.bashrc和.bash_profile文件<br>source ~&#x2F;.bashrc 其中source 用来更新刚刚更改的环境变量文件</p><p>#删除文件夹<br>rm -rf &#x2F;root&#x2F;logs&#x2F;game</p><p>#退出sudo<br>logout</p>]]></content>
    
    
    <categories>
      
      <category>Linux/WSL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>命令</tag>
      
      <tag>Shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>中止NVIDIA显卡上所有的任务</title>
    <link href="/omcat.github.io/2025/02/21/%E4%B8%AD%E6%AD%A2nvidia%E6%98%BE%E5%8D%A1%E4%B8%8A%E6%89%80%E6%9C%89%E7%9A%84%E4%BB%BB%E5%8A%A1/"/>
    <url>/omcat.github.io/2025/02/21/%E4%B8%AD%E6%AD%A2nvidia%E6%98%BE%E5%8D%A1%E4%B8%8A%E6%89%80%E6%9C%89%E7%9A%84%E4%BB%BB%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<p>​​查找使用 GPU 的进程 PID​​：<br>nvidia-smi –query-compute-apps&#x3D;pid –format&#x3D;csv,noheader,nounits</p><p>强制终止所有 GPU 进程​​：<br>sudo kill -9 $(nvidia-smi –query-compute-apps&#x3D;pid –format&#x3D;csv,noheader,nounits)</p>]]></content>
    
    
    <categories>
      
      <category>Linux/WSL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>NVIDIA</tag>
      
      <tag>GPU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WSL代理设置</title>
    <link href="/omcat.github.io/2025/02/21/wsl%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE/"/>
    <url>/omcat.github.io/2025/02/21/wsl%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>本机IP：<br>10.15.47.5</p><p>本地代理软件端口：<br>7890</p><p>虚拟机对接本地代理（当换了网络wifi之后这个代理地址也要修改否则连不上网）：<br>export http_proxy&#x3D;”<a href="http://10.15.47.5:7890/">http://10.15.47.5:7890</a>“<br>export https_proxy&#x3D;”<a href="http://10.15.47.5:7890/">http://10.15.47.5:7890</a>“</p><p>验证代理成功<br>curl <a href="http://www.google.com/">www.google.com</a></p><p>注意事项<br>虚拟机终端窗口关闭后，代理失效，下一次需重新设置，或者写入到 ~&#x2F;.bashrc 文件内保存，执行source ~&#x2F;.bashrc ，可永久生效<br>但是，代理软件必须一直开启，关闭后，虚拟机找不到代理服务，无法连接网络。</p>]]></content>
    
    
    <categories>
      
      <category>Linux/WSL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
      <tag>WSL</tag>
      
      <tag>代理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jupyter Notebook使用教程</title>
    <link href="/omcat.github.io/2025/02/21/%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8jupyter_notebook%E7%9B%B8%E5%85%B3%E7%9A%84%E6%95%99%E7%A8%8B%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <url>/omcat.github.io/2025/02/21/%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8jupyter_notebook%E7%9B%B8%E5%85%B3%E7%9A%84%E6%95%99%E7%A8%8B%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>有一些python库为了方便教学，除了说明文档外会附加ipynb文件来进行教学，非常直观且便于初学者理解，但是jupyter notebook不太开箱即用，有一些坑需要避免。</p><ol><li><p>在新的虚拟环境中安装完python包之后，需要确保我们新创建的虚拟环境可以被jupyter notebook的kernel所访问，执行以下代码：<br>python -m ipykernel install –user –name 新环境名称 –display-name “Python [conda env:新环境名称”]；</p></li><li><p>在ipynb文件所在路径conda activate 新的虚拟环境，然后在命令行执行jupyter notebook，跳转到网页；</p></li><li><p>双击打开ipynb文件后更改kernel到我们为这个ipynb新创建的虚拟环境中去就可以运行代码了。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Python/机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Jupyter</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用parallel同时提交多个sh脚本</title>
    <link href="/omcat.github.io/2025/02/21/%E7%94%A8parallel%E5%90%8C%E6%97%B6%E6%8F%90%E4%BA%A4%E5%A4%9A%E4%B8%AAsh/"/>
    <url>/omcat.github.io/2025/02/21/%E7%94%A8parallel%E5%90%8C%E6%97%B6%E6%8F%90%E4%BA%A4%E5%A4%9A%E4%B8%AAsh/</url>
    
    <content type="html"><![CDATA[<h1 id="确保每个文件有执行权限"><a href="#确保每个文件有执行权限" class="headerlink" title="确保每个文件有执行权限"></a>确保每个文件有执行权限</h1><p>chmod +x *.sh</p><h1 id="运行所有的sh"><a href="#运行所有的sh" class="headerlink" title="运行所有的sh"></a>运行所有的sh</h1><p>ls *.sh | parallel sh {}</p><h1 id="同时提交当前路径下多个文件夹内的多个sh脚本"><a href="#同时提交当前路径下多个文件夹内的多个sh脚本" class="headerlink" title="同时提交当前路径下多个文件夹内的多个sh脚本"></a>同时提交当前路径下多个文件夹内的多个sh脚本</h1><p>要使用 <code>parallel</code> 命令同时提交 91 个文件夹内的 sh 脚本，你可以按以下方式修改命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">seq</span> 1 91 | parallel <span class="hljs-string">&#x27;cd job_&#123;&#125;_freq &amp;&amp; sh job_&#123;&#125;.sh&#x27;</span><br></code></pre></td></tr></table></figure><p>这个命令的工作原理如下：</p><ol><li><p><code>seq 1 91</code> 生成从 1 到 91 的序列。</p></li><li><p><code>parallel</code> 命令并行执行后面的命令，对每个序列数字执行一次。</p></li><li><p>对于每个数字 <code>&#123;&#125;</code>:</p><ul><li><code>cd job_&#123;&#125;_freq</code> 进入对应的文件夹</li><li><code>&amp;&amp; sh job_&#123;&#125;.sh</code> 执行该文件夹中的 sh 脚本</li></ul></li><li><p>整个过程并行进行，同时处理多个文件夹和脚本。</p></li></ol><p>使用这个命令，你可以同时提交所有 91 个文件夹中的脚本。请注意，这会同时运行大量进程，可能会对系统资源造成压力。如果需要限制同时运行的任务数量，可以使用 <code>-j</code> 参数，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">seq</span> 1 91 | parallel -j 10 <span class="hljs-string">&#x27;cd job_&#123;&#125;_freq &amp;&amp; sh job_&#123;&#125;.sh&#x27;</span><br></code></pre></td></tr></table></figure><p>这会限制 <code>parallel</code> 最多同时运行 10 个任务。你可以根据你的系统资源和需求调整这个数字。</p>]]></content>
    
    
    <categories>
      
      <category>Linux/WSL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Shell</tag>
      
      <tag>parallel</tag>
      
      <tag>脚本</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>超算的GRRM运行指令</title>
    <link href="/omcat.github.io/2025/02/21/%E8%B6%85%E7%AE%97%E7%9A%84GRRM%E8%BF%90%E8%A1%8C%E6%8C%87%E4%BB%A4/"/>
    <url>/omcat.github.io/2025/02/21/%E8%B6%85%E7%AE%97%E7%9A%84GRRM%E8%BF%90%E8%A1%8C%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>加载环境：<br>source &#x2F;work&#x2F;home&#x2F;casdao&#x2F;kdywwldut&#x2F;kdywwldut&#x2F;software&#x2F;GRRM14Beta&#x2F;env.sh<br>这边还在您的家目录下放了个调度脚本GRRMpBeta.slurm，您可以参考修改下提交作业</p><p>#!&#x2F;bin&#x2F;bash<br>#SBATCH -J test<br>#SBATCH -p xhacnormala<br>#SBATCH -N 1<br>#SBATCH -n 4<br>#SBATCH -o %j.o<br>#SBATCH -e %j.e<br>source &#x2F;work&#x2F;home&#x2F;casdao&#x2F;kdywwldut&#x2F;kdywwldut&#x2F;software&#x2F;GRRM14Beta&#x2F;env.sh</p><p>GRRMpBeta</p>]]></content>
    
    
    <categories>
      
      <category>量子化学软件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GRRM</tag>
      
      <tag>计算化学</tag>
      
      <tag>超算</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
