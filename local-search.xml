<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/omcat.github.io/2025/02/21/%E5%8E%9F%E5%AD%90%E6%95%B0%E5%A4%A7%E4%BA%8E100%E7%9A%84%E5%A4%8D%E6%9D%82%E4%B8%8D%E5%AF%B9%E7%A7%B0%E6%9C%89%E6%9C%BA%E9%87%91%E5%B1%9E%E5%82%AC%E5%8C%96%E5%8F%8D%E5%BA%94%E7%9A%84%E8%BF%87%E6%B8%A1%E6%80%81%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/"/>
    <url>/omcat.github.io/2025/02/21/%E5%8E%9F%E5%AD%90%E6%95%B0%E5%A4%A7%E4%BA%8E100%E7%9A%84%E5%A4%8D%E6%9D%82%E4%B8%8D%E5%AF%B9%E7%A7%B0%E6%9C%89%E6%9C%BA%E9%87%91%E5%B1%9E%E5%82%AC%E5%8C%96%E5%8F%8D%E5%BA%94%E7%9A%84%E8%BF%87%E6%B8%A1%E6%80%81%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="原子数大于100的复杂不对称有机金属催化反应的过渡态优化方法"><a href="#原子数大于100的复杂不对称有机金属催化反应的过渡态优化方法" class="headerlink" title="原子数大于100的复杂不对称有机金属催化反应的过渡态优化方法"></a>原子数大于100的复杂不对称有机金属催化反应的过渡态优化方法</h1><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><ul><li>如果提前已知反应机理：了解反应机理和反应的实验条件（反应温度、溶剂、压力）；</li><li>未知反应机理：根据猜测分析反应机理，并制定计算分析计划，分步搜索过渡态，最终绘制reaction profile；</li><li>确定过渡态结构优化&#x2F;频率分析和电子能量计算两步骤的泛函，基组&#x2F;赝势基组，色散校正项。</li></ul><h2 id="计算流程"><a href="#计算流程" class="headerlink" title="计算流程"></a>计算流程</h2><ol><li><p>手动建立反应络合体系的过渡态初猜结构；</p></li><li><p>采用Gaussian+GFN2-xTB快速搜索过渡态初猜结构；</p></li><li><p>利用GENConf-TS固定反应位点，基于分子动力学方法，指定温度进行最低能量构象搜索；</p><ul><li><a href="http://bbs.keinsci.com/thread-20063-1-1.html">http://bbs.keinsci.com/thread-20063-1-1.html</a></li><li><a href="http://sobereva.com/165">根据Boltzmann分布计算分子不同构象所占比例</a>：<a href="http://sobereva.com/165">http://sobereva.com/165</a></li><li><a href="http://bbs.keinsci.com/thread-577-1-1.html">http://bbs.keinsci.com/thread-577-1-1.html</a></li><li><a href="http://bbs.keinsci.com/forum.php?mod=viewthread&tid=2388&highlight=gentor">http://bbs.keinsci.com/forum.php?mod=viewthread&amp;tid=2388&amp;highlight=gentor</a></li></ul></li><li><p>基于最低能量构象，重新创建Gaussian的输入文件。对于较大体系，过渡态优化的计算指令可按照如下方式渐进，在有限计算资源下最快找到DFT精度级别的可用过渡态结构：</p><ul><li><p>首先用opt&#x3D;(ts,noeigen,calcfc,recalc&#x3D;3)，或者recalc&#x3D;5成本更低一些；</p></li><li><p>如果不收敛，可尝试opt&#x3D;(ts,noeigen,calcfc,recalc&#x3D;3,maxstep&#x3D;3,notrust)，这样基本大部分都能成功；</p></li><li><p>再进一步，采用opt&#x3D;(ts,noeigen,calcall)，每一步都精确计算Hessian，计算成本最高，但是能够保证不会陷入优化振荡。</p></li><li><p>优化指令的技术解释：</p><p>一般采用的计算精度级别越高，势能面越精确，因此直接采用calcfc命令计算由于Hessian只在第一步计算了精确值，大体系优化到后期容易陷入优化振荡，也就是从optimization中可以看到体系的能量一开始是下降的，但后面优化到两百步以上基本就在反复振荡，难以收敛到精确的鞍点（一般正常收敛150个原子体系需要100+步优化就成功了，步骤更多的基本就是陷入振荡了）。</p><p>这时候，需要采用recalc命令结合calcfc使用，每走n步就重新计算精确Hessian，并结合maxstep调整每一次优化的步长上限来走出势阱。</p><p><em>opt&#x3D;maxstep&#x3D;N（等价于IOp(1&#x2F;8&#x3D;N)）可以将步长上限（也称置信半径）调整到0.01N Bohr或弧度，默认是30。当按照优化方法判断出的下一步几何变量的变化超过这个数值，则实际的改变量会调节到恰好等于这个上限值（具体来说，是在置信半径对应的球面上做最小化寻找最佳的位置）。如果优化发生震荡，且每步位移不是很大而受力较大的话，往往表明优化过程陷在比较深、比较窄的势阱里，此时可以降低步长上限，比如降低到N&#x3D;5乃至N&#x3D;3，以避免每次都走过头而始终达不到势能面极小点。减小步长的做法不要在优化过程中过早地使用，否则由于优化过程走得太慢，所需的优化步数会增加。另外，如果用了calcall，减小步长上限不一定有好处，因为在精确Hessian下进行优化，每一步走的是比较准确的，人为篡改了步长有可能还阻碍收敛。</em></p><p><em>注意，maxstep设的只是最初的步长上限。随着优化的进行，步长上限其实是动态调整的。如果想一直用自己的设定，需要在opt中加上NoTrust关键词。对于结构反复微小震荡的情况，在使用maxstep减小步长上限的同时总建议同时写上此关键词。</em>*</p><p><em>（<a href="http://sobereva.com/164%EF%BC%89">http://sobereva.com/164）</a></em></p></li></ul></li><li><p>限制性优化技巧</p><ul><li>对于GENConf-TS得到的最低能量构象，或者是之前优化未收敛的几何结构，可以提取出来，固定其过渡态反应位点，进行限制性几何结构最小化，最后将最小化结构作为过渡态初猜来用于过渡态的精确搜索。固定反应位点可以采用Gaussview手动操作，教程<a href="http://bbs.keinsci.com/thread-9022-1-1.html%E3%80%82%E5%8F%B3%E9%94%AE%E7%82%B9%E5%87%BB%E9%9C%80%E8%A6%81%E5%86%BB%E7%BB%93%E7%9A%84%E5%8E%9F%E5%AD%90%EF%BC%8C%E9%80%89%E6%8B%A9select%EF%BC%8C%E5%8E%9F%E5%AD%90%E5%8F%98%E4%B8%BA%E9%BB%84%E8%89%B2%EF%BC%8C%E9%80%89%E5%AE%8C%E4%BA%86%E4%B9%8B%E5%90%8E%EF%BC%8C%E8%BF%9B%E5%85%A5Tools">http://bbs.keinsci.com/thread-9022-1-1.html。右键点击需要冻结的原子，选择select，原子变为黄色，选完了之后，进入Tools</a> - Atom Groups，把类别切换到Freeze，然后点击Freeze(Yes)那一行中的+号把选中的区域添加到这个冻结组里。此时体系就被分为冻结和不冻结的两个组了。保存之后发现被冻结的原子会在多出的一列数值中显示为-1，未被冻结的显示为0。</li><li>注意最后限制性优化完成后，复制坐标到TS优化任务的输入文件中要记得取消反应位点冻结。</li></ul></li><li><p>色散校正</p><ul><li><a href="http://sobereva.com/210">http://sobereva.com/210</a></li><li>em&#x3D;gd3bj和em&#x3D;gd3要分开看，有些基组有BJ阻尼的就不要加上bj的关键词。</li></ul></li><li><p>赝势基组</p><ul><li><a href="http://sobereva.com/373">http://sobereva.com/373</a></li></ul></li><li><p>溶剂化模型</p><ul><li><a href="http://sobereva.com/327">http://sobereva.com/327</a></li></ul></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/omcat.github.io/2025/02/21/Q2MM(TSFF)%E6%96%B9%E6%B3%95%E7%9A%84%E7%BB%86%E8%8A%82%E4%B8%8E%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <url>/omcat.github.io/2025/02/21/Q2MM(TSFF)%E6%96%B9%E6%B3%95%E7%9A%84%E7%BB%86%E8%8A%82%E4%B8%8E%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Q2MM-TSFF-方法的细节与实现原理"><a href="#Q2MM-TSFF-方法的细节与实现原理" class="headerlink" title="Q2MM(TSFF)方法的细节与实现原理"></a>Q2MM(TSFF)方法的细节与实现原理</h1><p>TSFF力场由来已久，早期的科研人员通过传统的分子力场方法直接应用到反应过渡态的方式进行反应动力学研究。Q2MM是一种经过Per-Ola Norrby课题组经过长达二十多年开发形成的全新具有高度实用价值的过渡态力场方法，目前已经被集成到ACE（Asymmetric catalytic evaluation）和CatVS（Catalyst virtual screening）这两个全自动化均相催化剂虚拟筛选软件之中，相关论文发表于Nat. Catalysis，JACS，JCC，Chem. Sci. 等期刊。</p><p>![1c07abea3fa047817db72a78c606ade](E:\Softwares\WeChat\WeChat Files\wxid_mw2n7uz79zg222\FileStorage\Temp\1c07abea3fa047817db72a78c606ade.png)</p><p>TSFF（过渡态力场，Transition State Force Field）方法是专门为准确预测化学反应中的过渡态能量而开发的。传统的力场方法（如分子力学）主要用于预测分子在平衡状态下的几何结构和相对稳定的构象转变。然而，传统力场通常不适用于反应中的键断裂或形成过程，因为这些过程涉及显著的几何变形和势能面的复杂变化。</p><p>TSFF方法的核心创新在于，将过渡态视为势能面的局部极小值，并通过重新构建力场参数，使得过渡态几何结构可以通过最小化能量直接获得(2003_TSFF过渡态力场的原理)。与常规力场方法不同，TSFF不依赖反应物和产物的势能面，而是直接将过渡态的几何信息融入力场中。这种方法不仅能够有效捕捉过渡态的能量，还能准确预测类似反应的相对反应性和选择性。</p><h2 id="TSFF的原理"><a href="#TSFF的原理" class="headerlink" title="TSFF的原理"></a>TSFF的原理</h2><h3 id="力场参数的回归流程"><a href="#力场参数的回归流程" class="headerlink" title="力场参数的回归流程"></a>力场参数的回归流程</h3><p><img src="C:\Users\TangKun\AppData\Roaming\Typora\typora-user-images\image-20241030101850260.png" alt="image-20241030101850260"></p><h3 id="过渡态结构优化上的巧思"><a href="#过渡态结构优化上的巧思" class="headerlink" title="过渡态结构优化上的巧思"></a>过渡态结构优化上的巧思</h3><p>TSFF拟合需要QM计算得到的精确过渡态的结构以及其对应的Hessian矩阵，这里对标签值中的Hessian矩阵进行了修改，将Hessian矩阵对角化之后得到的特征值中的唯一的负值改成了+1（一个相对较大的正特征值），这样做会使得过渡态沿着反应路径（MEP）的势能面的曲率反转变成正值，从可视化角度看就是势能面进行了翻转，如下图所示，原先过渡态上的鞍点变成了极小点，这样操作之后，就可以采用最小化优化算法来优化过渡态结构了。</p><p><img src="C:\Users\TangKun\AppData\Roaming\Typora\typora-user-images\image-20241030102428789.png" alt="image-20241030102428789"></p><!--补充知识1：E对R求二阶偏导数得到维度为(3*N，3*N)的Hessian矩阵，Hessian中的每一个元素都是关于两个不同原子坐标的能量的导数，其中对角元素是每个原子自身坐标关于能量的二阶偏导数，因此在使用Hessian时一般只需要上或者下三角阵即可包含全部所需的信息--><!--补充知识2：Hessian对角化操作可以求出特征值和特征向量，特征值对应分子系统中原子与原子之间的振动频率，特征向量对应振动方向及振幅 。特征值全部为正代表曲率为正，坐标不论怎么改变，不论向着什么方向，能量都会升高，这对应着势能面上的谷底（极小点）；特征值除了反应坐标方向为负值（曲率为负值，也是唯一的虚频的来源，参见下面的公式），其余都为正，这对应着过渡态，也就是势能面上的鞍点，因为这个点上的结构只有沿着反应坐标变化能量才会降低，而其他所有方向都会升高--><!--振动频率ω可以通过下面的公式计算，其中λ是特征值，μ是约化质量。--><p>$$<br>\omega&#x3D;\sqrt{\frac{1}{\mu}\lambda}<br>$$</p><h3 id="Hessian标签数据处理方式"><a href="#Hessian标签数据处理方式" class="headerlink" title="Hessian标签数据处理方式"></a>Hessian标签数据处理方式</h3><ul><li><p>首先通过QM做频率分析计算得到Hessian矩阵</p></li><li><p>对Hessian矩阵进行对角化得到特征值特征向量</p></li><li><p>将唯一的负特征值改为(+1)</p></li><li><p>根据修改之后的特征向量和特征值还原出新的Hessian</p></li><li><p>以新的Hessian拟合力场参数<br>$$<br>H&#x3D;X^TDX<br>$$</p><p>$$<br>\mathsf{H}^{\prime}&#x3D;\mathbf{X}^{\mathsf{T}}\mathbf{D}^{\prime}\mathbf{X}<br>$$</p><p>$$<br>\mathbf{D}&#x3D;\begin{bmatrix}-\lambda_1&amp;&amp;\cdots&amp;&amp;\mathbf{0}\\&amp;\mathbf{0}&amp;&amp;&amp;\\\vdots&amp;&amp;\lambda_\mathbf{8}&amp;&amp;\vdots\\&amp;&amp;&amp;\ddots&amp;\\\mathbf{0}&amp;\cdots&amp;&amp;&amp;\lambda_N\end{bmatrix}\quad\mathbf{D}^{\prime}&#x3D;\begin{bmatrix}+\mathbf{1}&amp;&amp;\cdots&amp;&amp;\mathbf{0}\\&amp;\mathbf{0}&amp;&amp;&amp;\\\vdots&amp;&amp;\lambda_\mathbf{\Phi}&amp;&amp;\vdots\\&amp;&amp;&amp;\ddots&amp;\\\mathbf{0}&amp;\cdots&amp;&amp;&amp;\lambda_N\end{bmatrix}<br>$$</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-comment"># 对角化Hessian矩阵</span><br>eigenvalues, eigenvectors = np.linalg.eig(hessian_matrix)<br></code></pre></td></tr></table></figure><h2 id="TSFF的发展以及拟合的注意事项"><a href="#TSFF的发展以及拟合的注意事项" class="headerlink" title="TSFF的发展以及拟合的注意事项"></a>TSFF的发展以及拟合的注意事项</h2><h3 id="关于Hessian的拟合"><a href="#关于Hessian的拟合" class="headerlink" title="关于Hessian的拟合"></a>关于Hessian的拟合</h3><p>TSFF拟合过程中惩罚函数是预测值与标签值之间的平方误差之和，最开始的工作中为了区分分别与键角、扭转、长程作用相关的Hessian元素，对惩罚函数中的平方误差和采用了加权因子缩放[Hagler and coworkers]。后续的更新版本TSFF去掉了加权因子缩放操作，直接拟合原始Hessian。</p><p>连接同一原子上两个坐标的Hessian元素，块对角元素，并不直接对应于力场相互作用，而是包含冗余数据。块对角线元素是非对角线元素的总和，并且倾向于将适当拟合的Hessian元素与可用分子力学函数无法表示的其他元素耦合。因此，通过从参数化过程中排除块对角元素，可以在不损失数据的情况下改进Hessian拟合，称之为“非对角线Hessian拟合”。</p><h2 id="如何采用NFF取代TSFF"><a href="#如何采用NFF取代TSFF" class="headerlink" title="如何采用NFF取代TSFF"></a>如何采用NFF取代TSFF</h2><h2 id="NFF取代TSFF进行催化剂虚拟筛选的尝试"><a href="#NFF取代TSFF进行催化剂虚拟筛选的尝试" class="headerlink" title="NFF取代TSFF进行催化剂虚拟筛选的尝试"></a>NFF取代TSFF进行催化剂虚拟筛选的尝试</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/omcat.github.io/2025/02/21/hello-world/"/>
    <url>/omcat.github.io/2025/02/21/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>NavicatGA学习笔记</title>
    <link href="/omcat.github.io/2025/02/21/NavicatGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/omcat.github.io/2025/02/21/NavicatGA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="NavicatGA学习笔记"><a href="#NavicatGA学习笔记" class="headerlink" title="NavicatGA学习笔记"></a>NavicatGA学习笔记</h1><h2 id="框架摘要"><a href="#框架摘要" class="headerlink" title="框架摘要"></a>框架摘要</h2><ul><li>该库分为GA基础父类求解器和好几种不同分子表示方式的GA子类求解器（<strong>selfies_solver、smiles_solver、xyz_solver</strong>，分别对应基于selfies、smiles和AaronTools的二维和三维分子结构表示方法）</li><li>其他类包含“封装器”和“化学模块”，封装器是很多个定义的常用用化学性质预测函数（如前线分子轨道能量、分子体积），包含依赖于pyscf来解决电子结构问题的功能，这些都可以用作<strong>适应度函数</strong>，可以很方便地自定义。</li><li>chimera模块(<a href="https://github.com/aspuru-guzik-group/chimera)%E8%A2%AB%E7%94%A8%E4%BA%8E%E6%A0%87%E9%87%8F%E5%8C%96%EF%BC%8C%E5%9C%A8%E6%B1%82%E8%A7%A3%E5%A4%9A%E7%9B%AE%E6%A0%87%E8%AE%BE%E8%AE%A1%E6%A1%88%E4%BE%8B%E6%97%B6%E7%94%A8%E5%88%B0%E3%80%82">https://github.com/aspuru-guzik-group/chimera)被用于标量化，在求解多目标设计案例时用到。</a></li></ul><h2 id="安装注意"><a href="#安装注意" class="headerlink" title="安装注意"></a>安装注意</h2><p>不要使用原说明文档中的安装指令，直接cd到源代码目录然后使用pip install . 安装。最后在使用过程总可能会缺少依赖库，挨个安装即可。</p><p>修改源代码的时候，可以在import开头写上：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python3</span><br><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><span class="hljs-keyword">import</span> sys<br>sys.path.insert(<span class="hljs-number">0</span>, <span class="hljs-string">&#x27;./navicatGA&#x27;</span>)<br></code></pre></td></tr></table></figure><p>这样可以实现导入的函数和类是从当前测试路径下的源代码来的，可以直接修改该路径下的源代码从而构建自己的修改版本。</p><h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><h3 id="整体概述"><a href="#整体概述" class="headerlink" title="整体概述"></a>整体概述</h3><ul><li>给定初始种群基因，可以是二维的smiles，也可以是scaffold三维结构。种群中的每一个个体都可以称之为染色体，而每个染色体的组成部分则可以称之为基因，基因就是我们的最基础的设计单元；</li><li><u>组装器和适应度函数</u>：组装器将基因片段组合成为染色体，也就是设计出的催化剂个体，适应度函数则将组装器生成的个体作为输入参数，并返回对应的适应度函数数值（一般是经过归一化处理，在0~1之间），优化器会尝试最大化适应度函数；</li><li><u>适应度函数</u>：适应度函数会根据具体的应用案例变化，作用是将候选催化剂的化学结构映射到其在给定反应中的性能指标，例如<strong>分子火山图</strong>方法；</li><li>逐代进行交叉、变异，然后适应度函数评估，直至设计出适应度最佳的催化剂结构。</li></ul><p><img src="C:\Users\TangKun\AppData\Roaming\Typora\typora-user-images\image-20250217203053805.png" alt="image-20250217203053805"></p><ul><li>图中的<strong>Scalarization</strong>操作意思是标量化，Chimera在NaviCat-GA中充当多目标优化的标量化器，其主要功能是将多个优化目标的结果综合评估为一个单一的适应度值。具体来说，用户可以通过为每个优化目标分配优先级和降级阈值来定制优化策略，Chimera则基于这些设定，评估候选解在种群中的相对表现，最终生成一个代表整体优化效果的得分。此外，Chimera能够有效平衡各优化目标之间的冲突，使得在遗传算法中能够更高效地进行多目标优化。（<em>每当需要优化多个属性时，通常会在两个或多个目标之间进行权衡，从而阻止最优解的存在。在这种情况下，可以根据决策者选择的标准来识别优化问题的大量解决方案，即所谓的帕累托前沿。</em>）主要有两种操作方式：①用户通过为不同的属性分配权重（例如，最终适应度选择性占60%，活性占40%），或使用阶跃函数定义硬边界（例如，当选择性降至某个值以下时，将适应度设为0），对优化问题施加选定的标准。</li></ul><p>选择策略有以下几种：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">allowed_selection_strategies = &#123;<br>    <span class="hljs-string">&quot;roulette_wheel&quot;</span>,<br>    <span class="hljs-string">&quot;two_by_two&quot;</span>,<br>    <span class="hljs-string">&quot;random&quot;</span>,<br>    <span class="hljs-string">&quot;tournament&quot;</span>,<br>    <span class="hljs-string">&quot;boltzmann&quot;</span>,<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="GenAlgSolver类的框架和原理详细解析"><a href="#GenAlgSolver类的框架和原理详细解析" class="headerlink" title="GenAlgSolver类的框架和原理详细解析"></a><code>GenAlgSolver</code>类的框架和原理详细解析</h3><h2 id="关于分子火山图volcano-plot"><a href="#关于分子火山图volcano-plot" class="headerlink" title="关于分子火山图volcano plot"></a>关于分子火山图volcano plot</h2><p>github地址：<a href="https://github.com/lcmd-epfl/volcanic">https://github.com/lcmd-epfl/volcanic</a></p><p>论文：<a href="https://doi.org/10.1038/s41596-022-00726-2">https://doi.org/10.1038/s41596-022-00726-2</a></p><h3 id="构建方式"><a href="#构建方式" class="headerlink" title="构建方式"></a>构建方式</h3><ul><li><p>论文方法</p><ul><li>使用密度泛函理论（DFT）计算催化循环的相对自由能。</li><li>根据线性自由能尺度关系（LFESRs），选择适当的描述变量（通常为某中间体的相对自由能）。</li><li>构建起伏曲线关系（SRP），并通过最小值提取法生成火山图。</li></ul></li><li><p>步骤</p><ol><li>确定催化机制，优化中间态和过渡态的几何结构。</li><li>选择一个具有电子和空间多样性的催化剂池（10-50种催化剂）。</li><li>获取所有催化循环中间态和过渡态的相对自由能数据。</li><li>确定线性缩 放关系，并选择最佳描述变量。</li><li>构建起伏曲线关系（SRP）和火山图。</li><li>（可选）生成转换频率（TOF）火山图。</li></ol></li><li><p>自动化工具</p><ul><li>提供了“volcanic” Python包，用于自动化火山图和活动图的构造过程。</li></ul></li></ul><h3 id="线性缩放关系-（LFESRs）"><a href="#线性缩放关系-（LFESRs）" class="headerlink" title="线性缩放关系**（LFESRs）**"></a>线性缩放关系**（LFESRs）**</h3><p>线性缩放关系是指描述变量（descriptor variable）与其他中间体或过渡态的相对自由能（ΔG_RRS）之间的线性关系。这些关系是构建火山图和活动图的基础。</p><p>论文中指出，线性缩放关系的存在是因为不同的中间体或过渡态之间的能量变化具有规律性。例如，某个中间体的自由能变化可以通过另一个中间体的自由能变化来线性预测。</p><p><img src="C:\Users\TangKun\AppData\Roaming\Typora\typora-user-images\image-20250217210645880.png" alt="image-20250217210645880"></p><h4 id="1-如何确定线性缩放关系？"><a href="#1-如何确定线性缩放关系？" class="headerlink" title="1. 如何确定线性缩放关系？"></a><strong>1. 如何确定线性缩放关系？</strong></h4><p><strong>绘制自由能对比图</strong></p><ul><li>对于每个催化剂，计算出催化循环中所有中间体和过渡态的相对自由能（ΔG_RRS）。</li><li>将每个中间体的自由能与其他中间体&#x2F;过渡态的自由能进行对比，绘制自由能对自由能的散点图。</li></ul><!--例如：在Suzuki-Miyaura反应中，论文中提到，ΔG_RRS(Int2)（某中间体的自由能）可以与ΔG_RRS(TS1)（某过渡态的自由能）进行对比，查看是否存在线性关系。--><p><strong>进行线性回归</strong></p><ul><li>对每对中间体&#x2F;过渡态的自由能数据，进行线性回归（ordinary least squares, OLS）。</li><li>计算回归的质量指标，例如：<ul><li><strong>决定系数（R²）</strong>：衡量线性关系的拟合程度，R²越接近1，线性关系越好。</li><li>**平均绝对误差（MAE）**和**平均绝对百分比误差（MAPE）**：衡量回归误差的大小。</li></ul></li></ul><p><strong>选择最佳描述变量</strong></p><ul><li>根据回归质量指标，选择一个中间体的自由能作为描述变量（descriptor variable）。</li><li>通常，选择与其他中间体&#x2F;过渡态具有最高R²值、最低MAE和MAPE的中间体自由能作为描述变量。</li></ul><h4 id="2-实际案例：Suzuki-Miyaura反应"><a href="#2-实际案例：Suzuki-Miyaura反应" class="headerlink" title="2. 实际案例：Suzuki-Miyaura反应"></a>2. <strong>实际案例：Suzuki-Miyaura反应</strong></h4><p>在论文中，作者以Suzuki-Miyaura反应为例，具体描述了如何确定线性缩放关系和选择描述变量。</p><p><strong>描述变量的选择</strong></p><ul><li>催化循环包括多个中间体（Int1, Int2, etc.）和过渡态（TS1, TS2, etc.）。</li><li>通过线性回归分析，发现ΔG_RRS(Int2)（某中间体的自由能）与其他中间体&#x2F;过渡态的自由能具有最好的线性关系（R²&#x3D;0.8211）。</li><li>因此，ΔG_RRS(Int2)被选为描述变量。</li></ul><p><strong>线性缩放关系的构建</strong></p><ul><li>使用ΔG_RRS(Int2)作为描述变量，构建与其他中间体&#x2F;过渡态的自由能关系。</li><li>示例：ΔG_RRS(TS1) &#x3D; A × ΔG_RRS(Int2) + b，其中A是斜率，b是截距。</li></ul><h4 id="3-如何验证描述变量的选择？"><a href="#3-如何验证描述变量的选择？" class="headerlink" title="3. 如何验证描述变量的选择？"></a>3. <strong>如何验证描述变量的选择？</strong></h4><ul><li><strong>回归质量指标</strong>：确保描述变量与其他中间体&#x2F;过渡态的自由能具有高R²值和低误差。</li><li><strong>化学意义</strong>：描述变量应对应于催化循环中对活性有重要影响的中间体。</li><li><strong>预测能力</strong>：通过火山图预测催化剂的活性，并与实验数据进行对比验证。</li></ul><h4 id="4-如果没有明显的线性关系怎么办？"><a href="#4-如果没有明显的线性关系怎么办？" class="headerlink" title="4. 如果没有明显的线性关系怎么办？"></a>4. <strong>如果没有明显的线性关系怎么办？</strong></h4><p>如果线性缩放关系较差，可能是因为：</p><ol><li><strong>催化剂池不够多样化</strong>：增加催化剂池的多样性（电子效应和空间效应）。</li><li><strong>描述变量的选择不当</strong>：尝试其他中间体&#x2F;过渡态的自由能作为描述变量。</li><li><strong>催化机制复杂</strong>：可能需要引入第二个描述变量，构建活动图（multi-dimensional analysis）。</li></ol><h2 id="与GB-GA基于图的遗传算法的对比"><a href="#与GB-GA基于图的遗传算法的对比" class="headerlink" title="与GB-GA基于图的遗传算法的对比"></a>与GB-GA基于图的遗传算法的对比</h2><h3 id="为什么称为“基于图的遗传算法”（GB-GA）？"><a href="#为什么称为“基于图的遗传算法”（GB-GA）？" class="headerlink" title="为什么称为“基于图的遗传算法”（GB-GA）？"></a><strong>为什么称为“基于图的遗传算法”（GB-GA）？</strong></h3><p>论文中的遗传算法被称为“基于图的遗传算法”（Graph-Based Genetic Algorithm, GB-GA），是因为其核心操作直接作用于<strong>分子图结构</strong>（而非传统的字符串或向量表示）。分子图以原子为节点、化学键为边，保留了分子的拓扑结构和化学键信息，避免了传统基于SMILES字符串的遗传算法（如交叉和变异可能生成无效结构）的局限性。</p><hr><h3 id="与传统GA相比的优势"><a href="#与传统GA相比的优势" class="headerlink" title="与传统GA相比的优势"></a><strong>与传统GA相比的优势</strong></h3><p>传统遗传算法（GA）在分子优化中通常基于SMILES字符串或固定长度的向量表示，而GB-GA的优势主要体现在以下方面：</p><table><thead><tr><th align="center"><strong>对比维度</strong></th><th align="center"><strong>传统GA（如基于SMILES）</strong></th><th align="center"><strong>基于图的GA（GB-GA）</strong></th></tr></thead><tbody><tr><td align="center"><strong>表示方式</strong></td><td align="center">SMILES字符串（线性序列）</td><td align="center">分子图（节点&#x3D;原子，边&#x3D;化学键）</td></tr><tr><td align="center"><strong>化学合理性</strong></td><td align="center">交叉&#x2F;变异易生成无效SMILES，需额外验证</td><td align="center">直接在化学规则下操作，保证分子有效性</td></tr><tr><td align="center"><strong>结构灵活性</strong></td><td align="center">难以处理环状结构或复杂键合关系</td><td align="center">天然支持环、支链、多键等复杂结构</td></tr><tr><td align="center"><strong>优化效率</strong></td><td align="center">需频繁修复无效分子，计算开销大</td><td align="center">无需后处理，计算速度更快（论文中30秒&#x2F;次）</td></tr><tr><td align="center"><strong>化学空间探索</strong></td><td align="center">受限于SMILES语法，多样性较低</td><td align="center">通过子图交换直接探索新结构，多样性更高</td></tr></tbody></table><p><strong>核心优势总结</strong>：</p><ol><li><strong>分子有效性</strong>：交叉和变异操作基于化学规则（如价键规则），避免生成无效分子。</li><li><strong>计算高效性</strong>：省去无效结构的修复步骤，显著缩短优化时间。</li><li><strong>复杂结构支持</strong>：直接操作图结构，更适用于含环、多支链的分子优化。</li></ol><h3 id="基于分子图的遗传算法如何表示分子？"><a href="#基于分子图的遗传算法如何表示分子？" class="headerlink" title="基于分子图的遗传算法如何表示分子？"></a><strong>基于分子图的遗传算法如何表示分子？</strong></h3><p>在论文中，分子图通过以下方式表示和操作：</p><h4 id="1-分子图数据结构"><a href="#1-分子图数据结构" class="headerlink" title="1. 分子图数据结构"></a><strong>1. 分子图数据结构</strong></h4><ul><li><strong>节点（Atoms）</strong>：每个节点表示一个原子，附带属性（如原子类型、电荷等）。</li><li><strong>边（Bonds）</strong>：每条边表示化学键，附带键类型（单键、双键等）。</li><li><strong>实现工具</strong>：基于RDKit库将分子转换为图对象，确保化学规则的兼容性。</li></ul><h4 id="2-遗传操作设计"><a href="#2-遗传操作设计" class="headerlink" title="2. 遗传操作设计"></a><strong>2. 遗传操作设计</strong></h4><ul><li><strong>交叉（Crossover）</strong>：<br>选择两个父代分子，交换它们的子图（如随机选择一个公共子结构或键进行交换），生成新子代。<br><strong>示例</strong>：若两个分子均含苯环，可交换苯环上的取代基。</li><li><strong>变异（Mutation）</strong>：<br>对单个分子进行局部修改，包括：<ul><li><strong>原子替换</strong>：更改某个原子的类型（如C→N）。</li><li><strong>键修改</strong>：调整键的类型（如单键→双键）或添加&#x2F;删除键。</li><li><strong>子结构替换</strong>：用预定义片段（如-OH、-NH₂）替换原有子结构。</li></ul></li></ul><h4 id="3-论文中的具体实现"><a href="#3-论文中的具体实现" class="headerlink" title="3. 论文中的具体实现"></a><strong>3. 论文中的具体实现</strong></h4><ul><li><strong>初始种群</strong>：从ZINC250k数据集中随机选取分子作为初始种群。</li><li><strong>适应度函数</strong>：以惩罚后的log P值为目标（<code>J(m) = log P(m) - SA(m) - RingPenalty(m)</code>）。</li><li><strong>选择策略</strong>：采用锦标赛选择（Tournament Selection），保留高适应度个体。</li><li><strong>终止条件</strong>：设定固定进化代数（如50代）或收敛阈值。</li></ul><hr><h3 id="为什么GB-GA在论文中表现更优？"><a href="#为什么GB-GA在论文中表现更优？" class="headerlink" title="为什么GB-GA在论文中表现更优？"></a><strong>为什么GB-GA在论文中表现更优？</strong></h3><p>论文通过实验验证了GB-GA的优越性，主要原因包括：</p><ol><li><strong>直接操作化学结构</strong>：避免SMILES的语法约束，生成更多样且复杂的分子。</li><li><strong>高效探索化学空间</strong>：通过子图交换和局部变异，快速发现高log P值的结构（如扩展共轭体系或引入疏水基团）。</li><li><strong>低计算成本</strong>：无需GPU加速，单次优化仅需30秒，适合资源有限场景。</li></ol><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>GB-GA通过<strong>分子图表示</strong>和<strong>化学规则驱动的遗传操作</strong>，解决了传统GA在分子生成中的无效结构问题和探索效率瓶颈。其优势在于<strong>化学直观性</strong>、<strong>高效性</strong>和<strong>多样性</strong>，特别适用于需快速探索复杂化学空间的优化任务（如log P值最大化）。论文通过对比实验，验证了其在特定场景下优于机器学习方法的潜力。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>遗传算法</tag>
      
      <tag>化学</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
